<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL 三万字精华总结【转载】</title>
    <link href="/2022/06/30/MySQL-%E4%B8%89%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91/"/>
    <url>/2022/06/30/MySQL-%E4%B8%89%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源：Javakeeper  作者：派大新</p><p><strong>如有侵权，请联系 <a href="mailto:&#119;&#101;&#105;&#x79;&#117;&#108;&#105;&#110;&#108;&#98;&#106;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;">&#119;&#101;&#105;&#x79;&#117;&#108;&#105;&#110;&#108;&#98;&#106;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;</a> 删除</strong></p></blockquote><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/1ytsufudyo.png?imageView2/2/w/1620" alt="img"></p><blockquote><p>写在之前：不建议那种上来就是各种面试题罗列，然后背书式的去记忆，对技术的提升帮助很小，对正经面试也没什么帮助，有点东西的面试官深挖下就懵逼了。 个人建议把面试题看作是费曼学习法中的回顾、简化的环节，准备面试的时候，跟着题目先自己讲给自己听，看看自己会满意吗，不满意就继续学习这个点，如此反复，好的offer离你不远的，奥利给</p></blockquote><h2 id="一、MySQL架构"><a href="#一、MySQL架构" class="headerlink" title="一、MySQL架构"></a><strong>一、MySQL架构</strong></h2><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/0cs6x0o7ic.png?imageView2/2/w/1620" alt="img"></p><ul><li><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li><li><strong>服务层</strong>：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等</li><li><strong>引擎层</strong>：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</li><li><strong>存储层</strong>：第四层为<a href="https://cloud.tencent.com/product/cdcs?from=10680">数据存储</a>层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互</li></ul><blockquote><p>❝画出 MySQL 架构图，这种变态问题都能问的出来 MySQL 的查询流程具体是？or  一条SQL语句在MySQL中如何执行的？</p></blockquote><p>客户端请求 —&gt; 连接器（验证用户身份，给予权限）  —&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作） —&gt; 分析器（对SQL进行词法分析和语法分析操作）  —&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法）  —&gt; 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口） —&gt; 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）图：极客时间</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/k1td0um15w.jpeg?imageView2/2/w/1620" alt="img"></p><hr><blockquote><p>❝说说MySQL有哪些存储引擎？都有哪些区别？</p></blockquote><h2 id="二、存储引擎"><a href="#二、存储引擎" class="headerlink" title="二、存储引擎"></a><strong>二、存储引擎</strong></h2><p>存储引擎是MySQL的组件，用于处理不同表类型的SQL操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。</p><p>使用哪一种引擎可以灵活选择，<strong>一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求</strong>，使用合适的存储引擎，将会提高整个数据库的性能 。</p><p>MySQL服务器使用<strong>可插拔</strong>的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎 。</p><h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a><strong>查看存储引擎</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">-- 查看支持的存储引擎<br><span class="hljs-variable constant_">SHOW</span> <span class="hljs-variable constant_">ENGINES</span><br><br>-- 查看默认存储引擎<br><span class="hljs-variable constant_">SHOW</span> <span class="hljs-variable constant_">VARIABLES</span> <span class="hljs-variable constant_">LIKE</span> <span class="hljs-string">&#x27;storage_engine&#x27;</span><br><br>--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！<br>show create table tablename<br><br>--准确查看某个数据库中的某一表所使用的存储引擎<br>show table status like <span class="hljs-string">&#x27;tablename&#x27;</span><br>show table status <span class="hljs-keyword">from</span> database where name=<span class="hljs-string">&quot;tablename&quot;</span><br></code></pre></td></tr></table></figure><p>复制</p><h3 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a><strong>设置存储引擎</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">-- 建表时指定存储引擎。默认的就是<span class="hljs-variable constant_">INNODB</span>，不需要设置<br><span class="hljs-variable constant_">CREATE</span> <span class="hljs-variable constant_">TABLE</span> t1 (i <span class="hljs-variable constant_">INT</span>) <span class="hljs-variable constant_">ENGINE</span> = <span class="hljs-variable constant_">INNODB</span>;<br><span class="hljs-variable constant_">CREATE</span> <span class="hljs-variable constant_">TABLE</span> t2 (i <span class="hljs-variable constant_">INT</span>) <span class="hljs-variable constant_">ENGINE</span> = <span class="hljs-variable constant_">CSV</span>;<br><span class="hljs-variable constant_">CREATE</span> <span class="hljs-variable constant_">TABLE</span> t3 (i <span class="hljs-variable constant_">INT</span>) <span class="hljs-variable constant_">ENGINE</span> = <span class="hljs-variable constant_">MEMORY</span>;<br><br>-- 修改存储引擎<br><span class="hljs-variable constant_">ALTER</span> <span class="hljs-variable constant_">TABLE</span> t <span class="hljs-variable constant_">ENGINE</span> = <span class="hljs-title class_">InnoDB</span>;<br><br>-- 修改默认存储引擎，也可以在配置文件my.<span class="hljs-property">cnf</span>中修改默认引擎<br><span class="hljs-variable constant_">SET</span> default_storage_engine=<span class="hljs-variable constant_">NDBCLUSTER</span>;<br></code></pre></td></tr></table></figure><p>复制</p><p>默认情况下，每当 <code>CREATE TABLE</code> 或 <code>ALTER TABLE</code> 不能使用默认存储引擎时，都会生成一个警告。为了防止在所需的引擎不可用时出现令人困惑的意外行为，可以启用 <code>NO_ENGINE_SUBSTITUTION SQL</code> 模式。如果所需的引擎不可用，则此设置将产生错误而不是警告，并且不会创建或更改表</p><h3 id="存储引擎对比"><a href="#存储引擎对比" class="headerlink" title="存储引擎对比"></a><strong>存储引擎对比</strong></h3><p>常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。</p><p>InnoDB 现在是 MySQL 默认的存储引擎，支持<strong>事务、行级锁定和外键</strong></p><h4 id="文件存储结构对比"><a href="#文件存储结构对比" class="headerlink" title="文件存储结构对比"></a><strong>文件存储结构对比</strong></h4><p>在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 <code>.frm</code> 文件，<code>.frm</code> 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有<code>.frm</code>文件，命名方式为 数据表名.frm，如user.frm。</p><p>查看MySQL 数据保存在哪里：<code>show variables like &#39;data%&#39;</code></p><p>MyISAM 物理文件结构为：</p><ul><li><code>.frm</code>文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</li><li><code>.MYD</code> (<code>MYData</code>) 文件：MyISAM 存储引擎专用，用于存储MyISAM 表的数据</li><li><code>.MYI</code> (<code>MYIndex</code>)文件：MyISAM 存储引擎专用，用于存储MyISAM 表的索引相关信息</li></ul><p>InnoDB 物理文件结构为：</p><ul><li><code>.frm</code> 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</li><li><code>.ibd</code> 文件或 <code>.ibdata</code> 文件：这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。 独享表空间存储方式使用<code>.ibd</code>文件，并且每个表一个<code>.ibd</code>文件 共享表空间存储方式使用<code>.ibdata</code>文件，所有表共同使用一个<code>.ibdata</code>文件（或多个，可自己配置）</li></ul><blockquote><p>❝ps：正经公司，这些都有专业运维去做，数据备份、恢复啥的，让我一个 Javaer 搞这的话，加钱不？</p></blockquote><h4 id="面试这么回答"><a href="#面试这么回答" class="headerlink" title="面试这么回答"></a><strong>面试这么回答</strong></h4><ol><li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li><li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li><li>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>InnoDB 不保存表的具体行数，执行<code>select count(*) from table</code> 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li></ol><table><thead><tr><th align="left">对比项</th><th align="left">MyISAM</th><th align="left">InnoDB</th></tr></thead><tbody><tr><td align="left">主外键</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">事务</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">行表锁</td><td align="left">表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td align="left">行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td align="left">缓存</td><td align="left">只缓存索引，不缓存真实数据</td><td align="left">不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td align="left">表空间</td><td align="left">小</td><td align="left">大</td></tr><tr><td align="left">关注点</td><td align="left">性能</td><td align="left">事务</td></tr><tr><td align="left">默认安装</td><td align="left">是</td><td align="left">是</td></tr></tbody></table><blockquote><p>❝一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p></blockquote><p>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；</p><p>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</p><blockquote><p>❝哪个存储引擎执行 select count(*) 更快，为什么?</p></blockquote><p>MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。</p><ul><li>在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(*) from t 时，直接返回总数据。</li><li>在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(*) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。</li></ul><p>InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p><h2 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a><strong>三、数据类型</strong></h2><p>主要包括以下五大类：</p><ul><li>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</li><li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li><li>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</li><li>日期类型：Date、DateTime、TimeStamp、Time、Year</li><li>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/fqlbkr4qok.jpeg?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/repag3ujkx.jpeg?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/wjalehcilr.jpeg?imageView2/2/w/1620" alt="img"></p><blockquote><p>❝CHAR 和 VARCHAR 的区别？</p></blockquote><p>char是固定长度，varchar长度可变：</p><p>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p><p>存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间</p><p>相同点：</p><ol><li>char(n)，varchar(n)中的n都代表字符的个数</li><li>超过char，varchar最大长度n的限制后，字符串会被截断。</li></ol><p>不同点：</p><ol><li>char不论实际存储的字符数都会占用n个字符的空间，而varchar只会占用实际字符应该占用的字节空间加1（实际长度length，0&lt;&#x3D;length&lt;255）或加2（length&gt;255）。因为varchar保存数据时除了要保存字符串之外还会加一个字节来记录长度（如果列声明长度大于255则使用两个字节来保存长度）。</li><li>能存储的最大空间限制不一样：char的存储上限为255字节。</li><li>char在存储时会截断尾部的空格，而varchar不会。</li></ol><p>char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。</p><blockquote><p>❝列的字符串类型可以是什么？</p></blockquote><p>字符串类型是：SET、BLOB、ENUM、CHAR、CHAR、TEXT、VARCHAR</p><blockquote><p>❝BLOB和TEXT有什么区别？</p></blockquote><p>BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB：TINYBLOB、BLOB、MEDIUMBLO和 LONGBLOB</p><p>TEXT是一个不区分大小写的BLOB。四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。</p><p>BLOB 保存二进制数据，TEXT 保存字符数据。</p><hr><h2 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a><strong>四、索引</strong></h2><blockquote><p>❝说说你对 MySQL 索引的理解？ 数据库索引的原理，为什么要用 B+树，为什么不用二叉树？ 聚集索引与非聚集索引的区别？ InnoDB引擎中的索引策略，了解过吗？ 创建索引的方式有哪些？ 聚簇索引&#x2F;非聚簇索引，mysql索引底层实现，为什么不用B-tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p></blockquote><ul><li>MYSQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构，所以说<strong>索引的本质是：数据结构</strong></li><li>索引的目的在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 。</li><li>可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，<strong>数据库还维护者一个满足特定查找算法的数据结构</strong>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图是一种可能的索引方式示例。</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/on7tql4laj.jpeg?imageView2/2/w/1620" alt="img"></p><p>左边的数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值，和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到对应的数据，从而快速检索出符合条件的记录。</p><ul><li>索引本身也很大，不可能全部存储在内存中，<strong>一般以索引文件的形式存储在磁盘上</strong></li><li>平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，符合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。</li></ul><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a><strong>基本语法：</strong></h3><ul><li>创建：<ul><li>创建索引：<code>CREATE [UNIQUE] INDEX indexName ON mytable(username(length));</code> 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</li><li>修改表结构(添加索引)：<code>ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName)</code></li></ul></li><li>删除：<code>DROP INDEX [indexName] ON mytable;</code></li><li>查看：<code>SHOW INDEX FROM table_name\G</code>             –可以通过添加 \G 来格式化输出信息。</li><li>使用ALERT命令<ul><li><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</code> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li><li><code>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list</code> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li><li><code>ALTER TABLE tbl_name ADD INDEX index_name (column_list)</code> 添加普通索引，索引值可出现多次。</li><li><code>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)</code>该语句指定了索引为 FULLTEXT ，用于全文索引。</li></ul></li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h3><ul><li><strong>提高数据检索效率，降低数据库IO成本</strong></li><li><strong>降低数据排序的成本，降低CPU的消耗</strong></li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a><strong>劣势</strong></h3><ul><li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</li></ul><h3 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a><strong>MySQL索引分类</strong></h3><h4 id="数据结构角度"><a href="#数据结构角度" class="headerlink" title="数据结构角度"></a><strong>数据结构角度</strong></h4><ul><li>B+树索引</li><li>Hash索引</li><li>Full-Text全文索引</li><li>R-Tree索引</li></ul><h4 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a><strong>从物理存储角度</strong></h4><ul><li>聚集索引（clustered index）</li><li>非聚集索引（non-clustered index），也叫辅助索引（secondary index） 聚集索引和非聚集索引都是B+树结构</li></ul><h4 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a><strong>从逻辑角度</strong></h4><ul><li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li><li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li><li>多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li><li>唯一索引或者非唯一索引</li><li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</li></ul><blockquote><p>❝为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引 聚簇索引&#x2F;非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？ 使用索引查询一定能提高查询的性能吗？为什么?</p></blockquote><h3 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a><strong>MySQL索引结构</strong></h3><p><strong>首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a><strong>B+Tree索引</strong></h4><p>MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。</p><p><strong>先了解下 B-Tree 和 B+Tree 的区别</strong></p><h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a><strong>B-Tree</strong></h5><p>B-Tree是为磁盘等外存储设备设计的一种平衡查找树。</p><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：<code>show variables like &#39;innodb_page_size&#39;;</code></p><p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I&#x2F;O次数，提高查询效率。</p><p>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p><p>一棵m阶的B-Tree有如下特性：</p><ol><li>每个节点最多有m个孩子</li><li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m&#x2F;2)个孩子。</li><li>若根节点不是叶子节点，则至少有2个孩子</li><li>所有叶子节点都在同一层，且不包含其它关键字信息</li><li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li><li>关键字的个数n满足：ceil(m&#x2F;2)-1 &lt;&#x3D; n &lt;&#x3D; m-1</li><li>ki(i&#x3D;1,…n)为关键字，且关键字升序排序</li><li>Pi(i&#x3D;1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li></ol><p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/2qdgqaxj3f.png?imageView2/2/w/1620" alt="img"></p><p>图片：DobbinSoong</p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p><p>模拟查找关键字29的过程：</p><ol><li>根据根节点找到磁盘块1，读入内存。【磁盘I&#x2F;O操作第1次】</li><li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘I&#x2F;O操作第2次】</li><li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘I&#x2F;O操作第3次】</li><li>在磁盘块8中的关键字列表中找到关键字29。</li></ol><p>分析上面过程，发现需要3次磁盘I&#x2F;O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I&#x2F;O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I&#x2F;O取到内存的数据都发挥了作用，从而提高了查询效率。</p><h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a><strong>B+Tree</strong></h5><p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。</p><p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I&#x2F;O次数，进而影响查询效率。在B+Tree中，<strong>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上</strong>，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p><p>B+Tree相对于B-Tree有几点不同：</p><ol><li>非叶子节点只存储键值信息；</li><li>所有叶子节点之间都有一个链指针；</li><li>数据记录都存放在叶子节点中</li></ol><p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/rpnddj90bf.jpeg?imageView2/2/w/1620" alt="img"></p><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p><p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB&#x2F;(8B+8B)&#x3D;1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 &#x3D; 10亿 条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I&#x2F;O操作。</p><p>B+Tree性质</p><ol><li>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h&#x3D;㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m &#x3D; 磁盘块的大小 &#x2F; 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</li><li>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即<strong>索引的最左匹配特性</strong>。</li></ol><h5 id="MyISAM主键索引与辅助索引的结构"><a href="#MyISAM主键索引与辅助索引的结构" class="headerlink" title="MyISAM主键索引与辅助索引的结构"></a><strong>MyISAM主键索引与辅助索引的结构</strong></h5><p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”非聚簇索引”。MyISAM的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/gpigsmut2b.jpeg?imageView2/2/w/1620" alt="img"></p><p>在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量（通过偏移量访问就是随机访问，速度很快）。</p><p>主索引是指主键索引，键值不可能重复；辅助索引则是普通索引，键值可能重复。</p><p>通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。</p><h5 id="InnoDB主键索引与辅助索引的结构"><a href="#InnoDB主键索引与辅助索引的结构" class="headerlink" title="InnoDB主键索引与辅助索引的结构"></a><strong>InnoDB主键索引与辅助索引的结构</strong></h5><p><strong>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录</strong>（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，<strong>InnoDB的数据文件本身就是主键索引文件</strong>，这样的索引被称为“聚簇索引”，一个表只能有一个聚簇索引。</p><h6 id="主键索引："><a href="#主键索引：" class="headerlink" title="主键索引："></a><strong>主键索引：</strong></h6><p>我们知道InnoDB索引是聚集索引，它的索引和数据是存入同一个.idb文件中的，因此它的索引结构是在同一个树节点中同时存放索引和数据，如下图中最底层的叶子节点有三行数据，对应于数据表中的id、stu_id、name数据项。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/7p5jqjdl1z.jpeg?imageView2/2/w/1620" alt="img"></p><p>在Innodb中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的，在数据段中。Innodb的数据文件可以按照表来切分（只需要开启<code>innodb_file_per_table)</code>，切分后存放在<code>xxx.ibd</code>中，默认不切分，存放在<code>xxx.ibdata</code>中。</p><h6 id="辅助（非主键）索引："><a href="#辅助（非主键）索引：" class="headerlink" title="辅助（非主键）索引："></a><strong>辅助（非主键）索引：</strong></h6><p>这次我们以示例中学生表中的name列建立辅助索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是辅助索引，按照ASCII码进行排序，第二行的整数是主键的值。</p><p>这就意味着，对name列进行条件搜索，需要两个步骤：</p><p>① 在辅助索引上检索name，到达其叶子节点获取对应的主键；</p><p>② 使用主键在主索引上再进行对应的检索操作</p><p>这也就是所谓的“<strong>回表查询</strong>”</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/6byorx7nbq.jpeg?imageView2/2/w/1620" alt="img"></p><p><strong>InnoDB 索引结构需要注意的点</strong></p><ol><li>数据文件本身就是索引文件</li><li>表数据文件本身就是按 B+Tree 组织的一个索引结构文件</li><li>聚集索引中叶节点包含了完整的数据记录</li><li>InnoDB 表必须要有主键，并且推荐使用整型自增主键</li></ol><p>正如我们上面介绍 InnoDB 存储结构，索引与数据是共同存储的，不管是主键索引还是辅助索引，在查找时都是通过先查找到索引节点才能拿到相对应的数据，如果我们在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</p><blockquote><p>❝那为什么推荐使用整型自增主键而不是选择UUID？</p></blockquote><ul><li>UUID是字符串，比整型消耗更多的存储空间；</li><li>在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；</li><li>自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id &gt; 5 &amp;&amp; id &lt; 20的条件查询语句。</li><li>在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易出现这样的情况，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。</li></ul><blockquote><p>❝为什么非主键索引结构叶子节点存储的是主键值？</p></blockquote><p>保证数据一致性和节省存储空间，可以这么理解：商城系统订单表会存储一个用户ID作为关联外键，而不推荐存储完整的用户信息，因为当我们用户表中的信息（真实名称、手机号、收货地址···）修改后，不需要再次维护订单表的用户数据，同时也节省了存储空间。</p><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a><strong>Hash索引</strong></h4><ul><li>主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。 检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。 MySQL目前有Memory引擎和NDB引擎支持Hash索引。</li></ul><h4 id="full-text全文索引"><a href="#full-text全文索引" class="headerlink" title="full-text全文索引"></a><strong>full-text全文索引</strong></h4><ul><li>全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。</li><li>它用于替代效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</li><li>同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应Btree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</li></ul><h4 id="R-Tree空间索引"><a href="#R-Tree空间索引" class="headerlink" title="R-Tree空间索引"></a><strong>R-Tree空间索引</strong></h4><p>空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型</p><blockquote><p>❝为什么Mysql索引要用B+树不是B树？</p></blockquote><p>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。</p><blockquote><p>❝面试官：为何不采用Hash方式？</p></blockquote><p>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</p><p>哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p><h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a><strong>哪些情况需要创建索引</strong></h3><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>单键&#x2F;组合索引的选择问题，高并发下倾向创建组合索引</li><li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li><li>查询中统计或分组字段</li></ol><h3 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a><strong>哪些情况不要创建索引</strong></h3><ol><li>表记录太少</li><li>经常增删改的表</li><li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li><li>频繁更新的字段不适合创建索引（会加重IO负担）</li><li>where条件里用不到的字段不创建索引</li></ol><h3 id="MySQL高效索引"><a href="#MySQL高效索引" class="headerlink" title="MySQL高效索引"></a><strong>MySQL高效索引</strong></h3><p><strong>覆盖索引</strong>（Covering Index）,或者叫索引覆盖， 也就是平时所说的不需要回表操作</p><ul><li>就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong>。</li><li>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。</li><li><strong>判断标准</strong> 使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为<strong>using index</strong>，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</li></ul><h2 id="五、MySQL查询"><a href="#五、MySQL查询" class="headerlink" title="五、MySQL查询"></a><strong>五、MySQL查询</strong></h2><blockquote><p>❝count(*) 和 count(1)和count(列名)区别   ps：这道题说法有点多</p></blockquote><p>执行效果上：</p><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li><li>count(1)包括了所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li></ul><p>执行效率上：</p><ul><li>列名为主键，count(列名)会比count(1)快</li><li>列名不为主键，count(1)会比count(列名)快</li><li>如果表多个列并且没有主键，则 count(1) 的执行效率优于 count(*)</li><li>如果有主键，则 select count（主键）的执行效率是最优的</li><li>如果表只有一个字段，则 select count(*) 最优。</li></ul><blockquote><p>❝MySQL中 in和 exists 的区别？</p></blockquote><ul><li>exists：exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前loop到的这条记录；反之，如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false</li><li>in：in查询相当于多个or条件的叠加</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> A <span class="hljs-variable constant_">WHERE</span> A.<span class="hljs-property">id</span> <span class="hljs-variable constant_">IN</span> (<span class="hljs-variable constant_">SELECT</span> id <span class="hljs-variable constant_">FROM</span> B);<br><span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> A <span class="hljs-variable constant_">WHERE</span> <span class="hljs-variable constant_">EXISTS</span> (<span class="hljs-variable constant_">SELECT</span> * <span class="hljs-keyword">from</span> B <span class="hljs-variable constant_">WHERE</span> B.<span class="hljs-property">id</span> = A.<span class="hljs-property">id</span>);<br></code></pre></td></tr></table></figure><p>复制</p><p><strong>如果查询的两个表大小相当，那么用in和exists差别不大</strong>。</p><p>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in：</p><blockquote><p>❝UNION和UNION ALL的区别?</p></blockquote><p>UNION和UNION ALL都是将两个结果集合并为一个，<strong>两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；</strong></p><ul><li>UNION在进行表连接后会筛选掉重复的数据记录（效率较低），而UNION ALL则不会去掉重复的数据记录；</li><li>UNION会按照字段的顺序进行排序，而UNION ALL只是简单的将两个结果合并就返回；</li></ul><h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a><strong>SQL执行顺序</strong></h3><ul><li>手写 <code>SELECT DISTINCT &lt;select_list&gt;</code> <code>FROM  &lt;left_table&gt; &lt;join_type&gt;</code> <code>JOIN  &lt;right_table&gt; ON &lt;join_condition&gt;</code> <code>WHERE  &lt;where_condition&gt;</code> <code>GROUP BY  &lt;group_by_list&gt;</code> <code>HAVING &lt;having_condition&gt;</code> <code>ORDER BY &lt;order_by_condition&gt;</code> <code>LIMIT &lt;limit_number&gt;</code></li><li>机读 <code>FROM  &lt;left_table&gt;</code> <code>ON &lt;join_condition&gt;</code> <code>&lt;join_type&gt; JOIN  &lt;right_table&gt;</code> <code>WHERE  &lt;where_condition&gt;</code> <code>GROUP BY  &lt;group_by_list&gt;</code> <code>HAVING &lt;having_condition&gt;</code> <code>SELECT</code> <code>DISTINCT &lt;select_list&gt;</code> <code>ORDER BY &lt;order_by_condition&gt;</code> <code>LIMIT &lt;limit_number&gt;</code></li><li>总结</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/fqw7htiq5e.jpeg?imageView2/2/w/1620" alt="img"></p><blockquote><p>❝mysql 的内连接、左连接、右连接有什么区别？ 什么是内连接、外连接、交叉连接、笛卡尔积呢？</p></blockquote><h3 id="Join图"><a href="#Join图" class="headerlink" title="Join图"></a><strong>Join图</strong></h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/34kk6hlu2q.jpeg?imageView2/2/w/1620" alt="img"></p><hr><h2 id="六、MySQL-事务"><a href="#六、MySQL-事务" class="headerlink" title="六、MySQL 事务"></a><strong>六、MySQL 事务</strong></h2><blockquote><p>❝事务的隔离级别有哪些？MySQL的默认隔离级别是什么？ 什么是幻读，脏读，不可重复读呢？ MySQL事务的四大特性以及实现原理 MVCC熟悉吗，它的底层原理？</p></blockquote><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><h3 id="ACID-—-事务基本要素"><a href="#ACID-—-事务基本要素" class="headerlink" title="ACID — 事务基本要素"></a><strong>ACID — 事务基本要素</strong></h3><p>事务是由一组SQL语句组成的逻辑处理单元，具有4个属性，通常简称为事务的ACID属性。</p><ul><li><strong>A (Atomicity) 原子性</strong>：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</li><li><strong>C (Consistency) 一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏</li><li><strong>I (Isolation)隔离性</strong>：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰</li><li><strong>D (Durability) 持久性</strong>：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li></ul><p><strong>并发事务处理带来的问题</strong></p><ul><li>更新丢失（Lost Update)：事务A和事务B选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题</li><li>脏读(Dirty Reads)：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li>不可重复读（Non-Repeatable Reads)：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li><li>幻读（Phantom Reads)：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p><strong>幻读和不可重复读的区别：</strong></p><ul><li><strong>不可重复读的重点是修改</strong>：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）</li><li><strong>幻读的重点在于新增或者删除</strong>：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入&#x2F;删除）</li></ul><p><strong>并发事务处理带来的问题的解决办法：</strong></p><ul><li>“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</li><li>“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：<ul><li>一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li><li>另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 <strong>MVCC</strong> 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。</li></ul></li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a><strong>事务隔离级别</strong></h3><p>数据库事务的隔离级别有4种，由低到高分别为</p><ul><li><strong>READ-UNCOMMITTED(读未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><p>查看当前数据库的事务隔离级别：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">show variables like <span class="hljs-string">&#x27;tx_isolation&#x27;</span><br></code></pre></td></tr></table></figure><p>复制</p><p>下面通过事例一一阐述在事务的并发操作中可能会出现脏读，不可重复读，幻读和事务隔离级别的联系。</p><p>数据库的事务隔离越严格，并发副作用越小，但付出的代价就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p><h4 id="Read-uncommitted"><a href="#Read-uncommitted" class="headerlink" title="Read uncommitted"></a><strong>Read uncommitted</strong></h4><p>读未提交，就是一个事务可以读取另一个未提交事务的数据。</p><p>事例：老板要给程序员发工资，程序员的工资是3.6万&#x2F;月。但是发工资时老板不小心按错了数字，按成3.9万&#x2F;月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。</p><p>分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。</p><p>那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。</p><h4 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a><strong>Read committed</strong></h4><p>读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。</p><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p><p>分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是<strong>不可重复读</strong>。</p><p>那怎么解决可能的不可重复读问题？Repeatable read ！</p><h4 id="Repeatable-read"><a href="#Repeatable-read" class="headerlink" title="Repeatable read"></a><strong>Repeatable read</strong></h4><p>重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。<strong>MySQL的默认事务隔离级别</strong> </p><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p><p>分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，<strong>不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作</strong>。</p><p><strong>什么时候会出现幻读？</strong></p><p>事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p><p>那怎么解决幻读问题？Serializable！</p><h4 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a><strong>Serializable 序列化</strong></h4><p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。简单来说，Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a><strong>比较</strong></h4><table><thead><tr><th align="left">事务隔离级别</th><th align="left">读数据一致性</th><th align="left">脏读</th><th align="left">不可重复读</th><th align="left">幻读</th></tr></thead><tbody><tr><td align="left">读未提交（read-uncommitted）</td><td align="left">最低级被，只能保证不读取物理上损坏的数据</td><td align="left">是</td><td align="left">是</td><td align="left">是</td></tr><tr><td align="left">读已提交（read-committed）</td><td align="left">语句级</td><td align="left">否</td><td align="left">是</td><td align="left">是</td></tr><tr><td align="left">可重复读（repeatable-read）</td><td align="left">事务级</td><td align="left">否</td><td align="left">否</td><td align="left">是</td></tr><tr><td align="left">串行化（serializable）</td><td align="left">最高级别，事务级</td><td align="left">否</td><td align="left">否</td><td align="left">否</td></tr></tbody></table><p>需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。</p><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p><p>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ</strong>（可重读）事务隔离级别下使用的是Next-Key Lock 算法，因此可以避免幻读的产生，这与其他数据库系统(如 <a href="https://cloud.tencent.com/product/sqlserver?from=10680">SQL Server</a>)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE</strong>(可串行化)隔离级别，而且保留了比较好的并发性能。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED</strong>(读已提交):，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ</strong>（可重读）并不会有任何性能损失。</p><h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a><strong>MVCC 多版本并发控制</strong></h3><p>MySQL的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。</p><p>可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。</p><p>MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。</p><p>典型的MVCC实现方式，分为<strong>乐观（optimistic）并发控制和悲观（pressimistic）并发控制</strong>。下边通过 InnoDB的简化版行为来说明 MVCC 是如何工作的。</p><p>InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p><p><strong>REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</strong></p><ul><li>SELECT InnoDB会根据以下两个条件检查每行记录： 只有符合上述两个条件的才会被查询出来<ul><li>InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的</li><li>行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除</li></ul></li><li>INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号</li><li>DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识</li><li>UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</li></ul><p>保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p><p>MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</p><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a><strong>事务日志</strong></h3><p>InnoDB 使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中。</p><p>事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 IO。</p><p>InnoDB 假设使用常规磁盘，随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。</p><p>InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。</p><p>InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。</p><p>事务日志可以帮助提高事务效率：</p><ul><li>使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</li><li>事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I&#x2F;O，而不像随机I&#x2F;O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。</li><li>事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。</li><li>如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。</li></ul><p>目前来说，大多数存储引擎都是这样实现的，我们通常称之为<strong>预写式日志</strong>（Write-Ahead Logging），修改数据需要写两次磁盘。</p><h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a><strong>事务的实现</strong></h3><p>事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。</p><p>事务的实现就是如何实现ACID特性。</p><p>事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现 。</p><blockquote><p>❝事务是如何通过日志来实现的，说得越深入越好。</p></blockquote><p>事务日志包括：<strong>重做日志redo</strong>和<strong>回滚日志undo</strong></p><ul><li><strong>redo log（重做日志</strong>） 实现持久化和原子性 在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。 在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录Redo Log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起。</li><li><strong>undo log（回滚日志）</strong>  实现一致性 undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。 Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）</li></ul><p>二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</p><blockquote><p>❝又引出个问题：你知道MySQL 有多少种日志吗？</p></blockquote><ul><li><strong>错误日志</strong>：记录出错信息，也记录一些警告信息或者正确的信息。</li><li><strong>查询日志</strong>：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。</li><li><strong>慢查询日志</strong>：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</li><li><strong>二进制日志</strong>：记录对数据库执行更改的所有操作。</li><li><strong>中继日志</strong>：中继日志也是二进制日志，用来给slave 库恢复</li><li><strong>事务日志</strong>：重做日志redo和回滚日志undo</li></ul><blockquote><p>❝分布式事务相关问题，可能还会问到 2PC、3PC，，，</p></blockquote><h3 id="MySQL对分布式事务的支持"><a href="#MySQL对分布式事务的支持" class="headerlink" title="MySQL对分布式事务的支持"></a><strong>MySQL对分布式事务的支持</strong></h3><p>分布式事务的实现方式有很多，既可以采用 InnoDB 提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。这里我们主要聊一下 InnoDB 对分布式事务的支持。</p><p>MySQL 从 5.0.3  InnoDB 存储引擎开始支持XA协议的分布式事务。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。</p><p>在MySQL中，使用分布式事务涉及一个或多个资源管理器和一个事务管理器。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/lquc7b04gf.png?imageView2/2/w/1620" alt="img"></p><p>如图，MySQL 的分布式事务模型。模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:</p><ul><li>应用程序：定义了事务的边界，指定需要做哪些事务；</li><li>资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；</li><li>事务管理器：协调参与了全局事务中的各个事务。</li></ul><p>分布式事务采用两段式提交（two-phase commit）的方式：</p><ul><li>第一阶段所有的事务节点开始准备，告诉事务管理器ready。</li><li>第二阶段事务管理器告诉每个节点是commit还是rollback。如果有一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性。</li></ul><h2 id="七、MySQL锁机制"><a href="#七、MySQL锁机制" class="headerlink" title="七、MySQL锁机制"></a><strong>七、MySQL锁机制</strong></h2><blockquote><p>❝数据库的乐观锁和悲观锁？ MySQL 中有哪几种锁，列举一下？ MySQL中InnoDB引擎的行锁是怎么实现的？ MySQL 间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的 sql 语句，死锁发生了如何解决，MySQL 有没有提供什么机制去解决死锁</p></blockquote><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。数据库锁定机制简单来说，就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。</p><p>打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买到还是另一个人买到的问题？这里肯定要用到事物，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。</p><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a><strong>锁的分类</strong></h3><p><strong>从对数据操作的类型分类</strong>：</p><ul><li><strong>读锁</strong>（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响</li><li><strong>写锁</strong>（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li></ul><p><strong>从对数据操作的粒度分类</strong>：</p><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。</p><ul><li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；</li><li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；</li><li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ul><p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p><table><thead><tr><th align="left"></th><th align="left">行锁</th><th align="left">表锁</th><th align="left">页锁</th></tr></thead><tbody><tr><td align="left">MyISAM</td><td align="left"></td><td align="left">√</td><td align="left"></td></tr><tr><td align="left">BDB</td><td align="left"></td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">InnoDB</td><td align="left">√</td><td align="left">√</td><td align="left"></td></tr><tr><td align="left">Memory</td><td align="left"></td><td align="left">√</td><td align="left"></td></tr></tbody></table><h3 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a><strong>MyISAM 表锁</strong></h3><p>MyISAM 的表锁有两种模式：</p><ul><li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li><li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li></ul><p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。其他线程的读、 写操作都会等待，直到锁被释放为止。</p><p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</p><h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a><strong>InnoDB 行锁</strong></h3><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li></ul><p><strong>索引失效会导致行锁变表锁</strong>。比如 vchar 查询不写单引号的情况。</p><h4 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a><strong>加锁机制</strong></h4><p><strong>乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题</strong></p><p>乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式</p><p>悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。另外与乐观锁相对应的，<strong>悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</strong></p><h4 id="锁模式-InnoDB有三种行锁的算法"><a href="#锁模式-InnoDB有三种行锁的算法" class="headerlink" title="锁模式(InnoDB有三种行锁的算法)"></a><strong>锁模式(InnoDB有三种行锁的算法)</strong></h4><ul><li>**记录锁(Record Locks)**：单个行记录上的锁。对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项； <code>SELECT * FROM table WHERE id = 1 FOR UPDATE;</code> 它会在 id&#x3D;1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id&#x3D;1 这一行 在通过 主键索引 与 唯一索引 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁： <code>-- id 列为主键列或唯一索引列</code> <code>UPDATE SET age = 50 WHERE id = 1;</code></li><li><strong>间隙锁（Gap Locks）</strong>：当我们使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙”。 InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。 间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的<code>Next-Key Locking</code> 算法，请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong>。 <code>SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;</code> 即所有在<code>（1，10）</code>区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。 GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况</li><li><strong>临键锁(Next-key Locks)<strong>：</strong>临键锁</strong>，是<strong>记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间。(临键锁的主要目的，也是为了避免<strong>幻读</strong>(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。) Next-Key 可以理解为一种特殊的<strong>间隙锁</strong>，也可以理解为一种特殊的<strong>算法</strong>。通过<strong>临建锁</strong>可以解决幻读的问题。每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，<code>InnoDB</code> 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。 对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</li></ul><blockquote><p>❝select for update有什么含义，会锁表还是锁行还是其他</p></blockquote><p>for update 仅适用于InnoDB，且必须在事务块(BEGIN&#x2F;COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。</p><p>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！假设有个表单 products ，里面有id跟name二个栏位，id是主键。</p><ul><li>明确指定主键，并且有此笔资料，row lock</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> products <span class="hljs-variable constant_">WHERE</span> id=<span class="hljs-string">&#x27;3&#x27;</span> <span class="hljs-variable constant_">FOR</span> <span class="hljs-variable constant_">UPDATE</span>;<br><span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> products <span class="hljs-variable constant_">WHERE</span> id=<span class="hljs-string">&#x27;3&#x27;</span> and type=<span class="hljs-number">1</span> <span class="hljs-variable constant_">FOR</span> <span class="hljs-variable constant_">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>复制</p><ul><li>明确指定主键，若查无此笔资料，无lock</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> products <span class="hljs-variable constant_">WHERE</span> id=<span class="hljs-string">&#x27;-1&#x27;</span> <span class="hljs-variable constant_">FOR</span> <span class="hljs-variable constant_">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>复制</p><ul><li>无主键，table lock</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> products <span class="hljs-variable constant_">WHERE</span> name=<span class="hljs-string">&#x27;Mouse&#x27;</span> <span class="hljs-variable constant_">FOR</span> <span class="hljs-variable constant_">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>复制</p><ul><li>主键不明确，table lock</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> products <span class="hljs-variable constant_">WHERE</span> id&lt;&gt;<span class="hljs-string">&#x27;3&#x27;</span> <span class="hljs-variable constant_">FOR</span> <span class="hljs-variable constant_">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>复制</p><ul><li>主键不明确，table lock</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> products <span class="hljs-variable constant_">WHERE</span> id <span class="hljs-variable constant_">LIKE</span> <span class="hljs-string">&#x27;3&#x27;</span> <span class="hljs-variable constant_">FOR</span> <span class="hljs-variable constant_">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>复制</p><p><strong>注1</strong>: FOR UPDATE仅适用于InnoDB，且必须在交易区块(BEGIN&#x2F;COMMIT)中才能生效。<strong>注2</strong>: 要测试锁定的状况，可以利用MySQL的Command Mode ，开二个视窗来做测试。</p><blockquote><p>❝MySQL 遇到过死锁问题吗，你是如何解决的？</p></blockquote><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h3><p><strong>死锁产生</strong>：</p><ul><li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环</li><li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁</li><li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li></ul><p><strong>检测死锁</strong>：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p><p><strong>死锁恢复</strong>：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p><p><strong>外部锁的死锁检测</strong>：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p><p><strong>死锁影响性能</strong>：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖<code>innodb_lock_wait_timeout</code>设置进行事务回滚。</p><p><strong>MyISAM避免死锁</strong>：</p><ul><li>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。</li></ul><p><strong>InnoDB避免死锁</strong>：</p><ul><li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用<code>SELECT ... FOR UPDATE</code>语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li><li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li><li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li><li>通过<code>SELECT ... LOCK IN SHARE MODE</code>获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li><li>改变事务隔离级别</li></ul><p>如果出现死锁，可以用 <code>show engine innodb status;</code>命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p><h2 id="八、MySQL调优"><a href="#八、MySQL调优" class="headerlink" title="八、MySQL调优"></a><strong>八、MySQL调优</strong></h2><blockquote><p>❝日常工作中你是怎么优化SQL的？ SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义？ 如何写sql能够有效的使用到复合索引？ 一条sql执行过长的时间，你如何优化，从哪些方面入手？ 什么是最左前缀原则？什么是最左匹配原则？</p></blockquote><h3 id="影响mysql的性能因素"><a href="#影响mysql的性能因素" class="headerlink" title="影响mysql的性能因素"></a><strong>影响mysql的性能因素</strong></h3><ul><li>业务需求对MySQL的影响(合适合度)</li><li>存储定位对MySQL的影响<ul><li>系统各种配置及规则数据</li><li>活跃用户的基本信息数据</li><li>活跃用户的个性化定制信息数据</li><li>准实时的统计信息数据</li><li>其他一些访问频繁但变更较少的数据</li><li>二进制多媒体数据</li><li>流水队列数据</li><li>超大文本数据</li><li>不适合放进MySQL的数据</li><li>需要放进缓存的数据</li></ul></li><li>Schema设计对系统的性能影响<ul><li>尽量减少对数据库访问的请求</li><li>尽量减少无用数据的查询请求</li></ul></li><li>硬件环境对系统性能的影响</li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a><strong>性能分析</strong></h3><h4 id="MySQL-Query-Optimizer"><a href="#MySQL-Query-Optimizer" class="headerlink" title="MySQL Query Optimizer"></a><strong>MySQL Query Optimizer</strong></h4><ol><li>MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间）</li><li>当客户端向 MySQL 请求一条 Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给 MySQL Query Optimize r时，MySQL Query Optimizer 首先会对整条 Query 进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息（如果有），看显示 Hint 信息是否可以完全确定该 Query 的执行计划。如果没有 Hint 或 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。</li></ol><h4 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈"></a><strong>MySQL常见瓶颈</strong></h4><ul><li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li><li>IO：磁盘I&#x2F;O瓶颈发生在装入数据远大于内存容量的时候</li><li>服务器硬件的性能瓶颈：top，free，iostat 和 vmstat来查看系统的性能状态</li></ul><h4 id="性能下降SQL慢-执行时间长-等待时间长-原因分析"><a href="#性能下降SQL慢-执行时间长-等待时间长-原因分析" class="headerlink" title="性能下降SQL慢 执行时间长 等待时间长 原因分析"></a><strong>性能下降SQL慢 执行时间长 等待时间长 原因分析</strong></h4><ul><li>查询语句写的烂</li><li>索引失效（单值、复合）</li><li>关联查询太多join（设计缺陷或不得已的需求）</li><li>服务器调优及各个参数设置（缓冲、线程数等）</li></ul><h4 id="MySQL常见性能分析手段"><a href="#MySQL常见性能分析手段" class="headerlink" title="MySQL常见性能分析手段"></a><strong>MySQL常见性能分析手段</strong></h4><p>在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有<strong>慢查询日志</strong>，<strong>EXPLAIN 分析查询</strong>，<strong>profiling分析</strong>以及<strong>show命令查询系统状态及系统变量</strong>，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p><h5 id="性能瓶颈定位"><a href="#性能瓶颈定位" class="headerlink" title="性能瓶颈定位"></a><strong>性能瓶颈定位</strong></h5><p>我们可以通过 show 命令查看 MySQL 状态及变量，找到系统的瓶颈：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Mysql</span>&gt; show status ——显示状态信息（扩展show status like ‘<span class="hljs-variable constant_">XXX</span>’）<br><br><span class="hljs-title class_">Mysql</span>&gt; show variables ——显示系统变量（扩展show variables like ‘<span class="hljs-variable constant_">XXX</span>’）<br><br><span class="hljs-title class_">Mysql</span>&gt; show innodb status ——显示<span class="hljs-title class_">InnoDB</span>存储引擎的状态<br><br><span class="hljs-title class_">Mysql</span>&gt; show processlist ——查看当前<span class="hljs-variable constant_">SQL</span>执行，包括执行状态、是否锁表等<br><br><span class="hljs-title class_">Shell</span>&gt; mysqladmin variables -u username -p password——显示系统变量<br><br><span class="hljs-title class_">Shell</span>&gt; mysqladmin extended-status -u username -p password——显示状态信息<br></code></pre></td></tr></table></figure><p>复制</p><h5 id="Explain-执行计划"><a href="#Explain-执行计划" class="headerlink" title="Explain(执行计划)"></a><strong>Explain(执行计划)</strong></h5><p>是什么：使用 <strong>Explain</strong> 关键字可以模拟优化器执行SQL查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈</p><p>能干吗：</p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><p>怎么玩：</p><ul><li>Explain + SQL语句</li><li>执行计划包含的信息（如果有分区表的话还会有<strong>partitions</strong>）</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/tktl1h0uvu.jpeg?imageView2/2/w/1620" alt="img"></p><p>expalin</p><p>各字段解释</p><ul><li><p>id</p><p>（select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序）</p><ul><li>id相同，执行顺序从上往下</li><li>id全不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li><li>id部分相同，执行顺序是先按照数字大的先执行，然后数字相同的按照从上往下的顺序执行</li></ul></li><li><p>select_type</p><p>（查询类型，用于区别普通查询、联合查询、子查询等复杂查询）</p><ul><li><strong>SIMPLE</strong> ：简单的select查询，查询中不包含子查询或UNION</li><li><strong>PRIMARY</strong>：查询中若包含任何复杂的子部分，最外层查询被标记为PRIMARY</li><li><strong>SUBQUERY</strong>：在select或where列表中包含了子查询</li><li><strong>DERIVED</strong>：在from列表中包含的子查询被标记为DERIVED，MySQL会递归执行这些子查询，把结果放在临时表里</li><li><strong>UNION</strong>：若第二个select出现在UNION之后，则被标记为UNION，若UNION包含在from子句的子查询中，外层select将被标记为DERIVED</li><li><strong>UNION RESULT</strong>：从UNION表获取结果的select</li></ul></li><li><p><strong>table</strong>（显示这一行的数据是关于哪张表的）</p></li><li><p>type</p><p>（显示查询使用了那种类型，从最好到最差依次排列</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p> ） tip: 一般来说，得保证查询至少达到range级别，最好到达ref</p><ul><li>system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现</li><li>const：表示通过索引一次就找到了，const 用于比较 primary key 或 unique 索引，因为只要匹配一行数据，所以很快，如将主键置于 where 列表中，mysql 就能将该查询转换为一个常量</li><li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</li><li>ref：非唯一性索引扫描，范围匹配某个单独值得所有行。本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，它可能也会找到多个符合条件的行，多以他应该属于查找和扫描的混合体</li><li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引</li><li>index：Full Index Scan，index于ALL区别为index类型只遍历索引树。通常比ALL快，因为索引文件通常比数据文件小。（<strong>也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的</strong>）</li><li>ALL：Full Table Scan，将遍历全表找到匹配的行</li></ul></li><li><p><strong>possible_keys</strong>（显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用）</p></li><li><p>key</p><ul><li>实际使用的索引，如果为NULL，则没有使用索引</li><li><strong>查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠，仅出现在key列表中</strong></li></ul></li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/gowvz0pqm6.jpeg?imageView2/2/w/1620" alt="img"></p><p>explain-key</p><ul><li><p>key_len</p><ul><li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好</li><li>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</li></ul></li><li><p><strong>ref</strong>（显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值）</p></li><li><p><strong>rows</strong>（根据表统计信息及索引选用情况，大致估算找到所需的记录所需要读取的行数）</p></li><li><p>Extra</p><p>（包含不适合在其他列中显示但十分重要的额外信息）</p><ol><li>using filesort: 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。常见于order by和group by语句中</li><li>Using temporary：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</li><li>using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现using where，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作</li><li>using where：使用了where过滤</li><li>using join buffer：使用了连接缓存</li><li>impossible where：where子句的值总是false，不能用来获取任何元祖</li><li>select tables optimized away：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li><li>distinct：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作</li></ol></li></ul><p><strong>case</strong>:</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/1oazpkqq5z.jpeg?imageView2/2/w/1620" alt="img"></p><p>explain-demo</p><ol><li>第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name……】</li><li>第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。【select id,name from t1 where other_column&#x3D;’’】</li><li>第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。【select id from t3】</li><li>第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行【select name,id from t2】</li><li>第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的&lt;union1,4&gt;表示用第一个和第四个select的结果进行union操作。【两个结果union操作】</li></ol><h5 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a><strong>慢查询日志</strong></h5><p>MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 <code>long_query_time</code> 值的 SQL，则会被记录到慢查询日志中。</p><ul><li><code>long_query_time</code> 的默认值为10，意思是运行10秒以上的语句</li><li>默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启</li></ul><p><strong>查看开启状态</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">SHOW</span> <span class="hljs-variable constant_">VARIABLES</span> <span class="hljs-variable constant_">LIKE</span> <span class="hljs-string">&#x27;%slow_query_log%&#x27;</span><br></code></pre></td></tr></table></figure><p>复制</p><p><strong>开启慢查询日志</strong></p><ul><li>临时配置：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">mysql&gt; set <span class="hljs-variable language_">global</span> slow_query_log=<span class="hljs-string">&#x27;ON&#x27;</span>;<br>mysql&gt; set <span class="hljs-variable language_">global</span> slow_query_log_file=<span class="hljs-string">&#x27;/var/lib/mysql/hostname-slow.log&#x27;</span>;<br>mysql&gt; set <span class="hljs-variable language_">global</span> long_query_time=<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>复制</p><p>​也可set文件位置，系统会默认给一个缺省文件host_name-slow.log</p><p>​使用set操作开启慢查询日志只对当前数据库生效，如果MySQL重启则会失效。</p><ul><li>永久配置 修改配置文件my.cnf或my.ini，在[mysqld]一行下面加入两个配置参数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[mysqld]<br>slow_query_log = <span class="hljs-variable constant_">ON</span><br>slow_query_log_file = <span class="hljs-regexp">/var/</span>lib/mysql/hostname-slow.<span class="hljs-property">log</span><br>long_query_time = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>复制</p><p>注：log-slow-queries 参数为慢查询日志存放的位置，一般这个目录要有 MySQL 的运行帐号的可写权限，一般都将这个目录设置为 MySQL 的数据存放目录；long_query_time&#x3D;2 中的 2 表示查询超过两秒才记录；在my.cnf或者 my.ini 中添加 log-queries-not-using-indexes 参数，表示记录下没有使用索引的查询。</p><p>可以用 <code>select sleep(4)</code> 验证是否成功开启。</p><p>在生产环境中，如果手工分析日志，查找、分析SQL，还是比较费劲的，所以MySQL提供了日志分析工具<strong>mysqldumpslow</strong>。</p><p>通过 mysqldumpslow –help 查看操作帮助信息</p><ul><li>得到返回记录集最多的10个SQL <code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log</code></li><li>得到访问次数最多的10个SQL <code>mysqldumpslow -s c -t 10 /var/lib/mysql/hostname-slow.log</code></li><li>得到按照时间排序的前10条里面含有左连接的查询语句 <code>mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/hostname-slow.log</code></li><li>也可以和管道配合使用 <code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log | more</code></li></ul><p><strong>也可使用 pt-query-digest 分析 RDS MySQL 慢查询日志</strong></p><h5 id="Show-Profile-分析查询"><a href="#Show-Profile-分析查询" class="headerlink" title="Show Profile 分析查询"></a><strong>Show Profile 分析查询</strong></h5><p>通过慢日志查询可以知道哪些 SQL 语句执行效率低下，通过 explain 我们可以得知 SQL 语句的具体执行情况，索引使用等，还可以结合<code>Show Profile</code>命令查看执行状态。</p><ul><li><p>Show Profile 是 MySQL 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p></li><li><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p></li><li><p>分析步骤 mysql&gt; show profiles; +———-+————+———————————+ | Query_ID | Duration   | Query                           | +———-+————+———————————+ |        1 | 0.00385450 | show variables like “profiling” | |        2 | 0.00170050 | show variables like “profiling” | |        3 | 0.00038025 | select * from t_base_user       | +———-+————+———————————+</p><ul><li>converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。</li><li>create tmp table 创建临时表，这个要注意</li><li>Copying to tmp table on disk   把内存临时表复制到磁盘</li><li>locked</li></ul><ol><li>诊断SQL，show profile cpu,block io for query  id(上一步前面的问题SQL数字号码)</li><li>日常开发需要注意的结论</li><li>是否支持，看看当前的mysql版本是否支持 <code>mysql&gt;Show  variables like &#39;profiling&#39;;  --默认是关闭，使用前需要开启</code></li><li>开启功能，默认是关闭，使用前需要开启 <code>mysql&gt;set profiling=1;</code></li><li>运行SQL</li><li>查看结果</li></ol></li></ul><blockquote><p>❝查询中哪些情况不会使用索引？</p></blockquote><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a><strong>性能优化</strong></h3><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a><strong>索引优化</strong></h4><ol><li>全值匹配我最爱</li><li>最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</li><li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右边的列</li><li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select</li><li>is null ,is not null 也无法使用索引</li><li>like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li><li>字符串不加单引号索引失效</li><li>少用or，用它来连接时会索引失效</li><li>&lt;，&lt;&#x3D;，&#x3D;，&gt;，&gt;&#x3D;，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!&#x3D; 则不行，会导致全表扫描</li></ol><p><strong>一般性建议</strong></p><ul><li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li><li>少用Hint强制索引</li></ul><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a><strong>查询优化</strong></h4><p><strong>永远小标驱动大表（小的数据集驱动大的数据集）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">slect * <span class="hljs-keyword">from</span> A where id <span class="hljs-keyword">in</span> (select id <span class="hljs-keyword">from</span> B)<span class="hljs-string">`等价于</span><br><span class="hljs-string">#等价于</span><br><span class="hljs-string">select id from B</span><br><span class="hljs-string">select * from A where A.id=B.id</span><br></code></pre></td></tr></table></figure><p>复制</p><p>当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">select * <span class="hljs-keyword">from</span> A where exists (select <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B where B.<span class="hljs-property">id</span>=A.<span class="hljs-property">id</span>)<br>#等价于<br>select * <span class="hljs-keyword">from</span> A<br>select * <span class="hljs-keyword">from</span> B where B.<span class="hljs-property">id</span> = A.<span class="hljs-property">id</span><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>复制</p><p>当 A 表的数据集小于B表的数据集时，用 exists优于用 in</p><p>注意：A表与B表的ID字段应建立索引。</p><p><strong>order by关键字优化</strong></p><ul><li>order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</li><li>MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；</li><li>ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列</li><li>尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀</li><li>如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序<ul><li>双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据</li><li>单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序</li></ul></li><li>优化策略<ul><li>增大sort_buffer_size参数的设置</li><li>增大max_lencth_for_sort_data参数的设置</li></ul></li></ul><p><strong>GROUP BY关键字优化</strong></p><ul><li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li><li>当无法使用索引列，增大 <code>max_length_for_sort_data</code> 参数的设置，增大<code>sort_buffer_size</code>参数的设置</li><li>where高于having，能写在where限定的条件就不要去having限定了</li></ul><h4 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a><strong>数据类型优化</strong></h4><p>MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。</p><ul><li>更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。 简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。</li><li>尽量避免NULL：通常情况下最好指定列为NOT NULL</li></ul><hr><h2 id="九、分区、分表、分库"><a href="#九、分区、分表、分库" class="headerlink" title="九、分区、分表、分库"></a><strong>九、分区、分表、分库</strong></h2><h3 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a><strong>MySQL分区</strong></h3><p>一般情况下我们创建的表对应一组存储文件，使用<code>MyISAM</code>存储引擎时是一个<code>.MYI</code>和<code>.MYD</code>文件，使用<code>Innodb</code>存储引擎时是一个<code>.ibd</code>和<code>.frm</code>（表结构）文件。</p><p>当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，保证其单个文件的执行效率</p><p><strong>能干嘛</strong></p><ul><li>逻辑数据分割</li><li>提高单一的写和读应用速度</li><li>提高分区范围读查询的速度</li><li>分割数据能够有多个不同的物理文件路径</li><li>高效的保存历史数据</li></ul><p><strong>怎么玩</strong></p><p>首先查看当前数据库是否支持分区</p><ul><li>MySQL5.6以及之前版本： <code>SHOW VARIABLES LIKE &#39;%partition%&#39;;</code></li><li>MySQL5.6： <code>show plugins;</code></li></ul><p><strong>分区类型及操作</strong></p><ul><li><strong>RANGE分区</strong>：基于属于一个给定连续区间的列值，把多行分配给分区。mysql将会根据指定的拆分策略，,把数据放在不同的表文件上。相当于在文件上,被拆成了小块.但是,对外给客户的感觉还是一张表，透明的。 按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，比如交易表啊，销售表啊等，可以根据年月来存放数据。可能会产生热点问题，大量的流量都打在最新的数据上了。 range 来分，好处在于说，扩容的时候很简单。</li><li><strong>LIST分区</strong>：类似于按RANGE分区，每个分区必须明确定义。它们的主要区别在于，LIST分区中每个分区的定义和选择是基于某列的值从属于一个值列表集中的一个值，而RANGE分区是从属于一个连续区间值的集合。</li><li><strong>HASH分区</strong>：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。 hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表</li><li><strong>KEY分区</strong>：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</li></ul><p><strong>看上去分区表很帅气，为什么大部分互联网还是更多的选择自己分库分表来水平扩展咧？</strong></p><ul><li>分区表，分区键设计不太灵活，如果不走分区键，很容易出现全表锁</li><li>一旦数据并发量上来，如果在分区表实施关联，就是一个灾难</li><li>自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定mysql是怎么玩的，不太可控</li></ul><blockquote><p>❝随着业务的发展，业务越来越复杂，应用的模块越来越多，总的数据量很大，高并发读写操作均超过单个数据库服务器的处理能力怎么办？</p></blockquote><p>这个时候就出现了<strong>数据分片</strong>，数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中。数据分片的有效手段就是对关系型数据库进行分库和分表。</p><p>区别于分区的是，分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。</p><blockquote><p>❝说说分库与分表的设计</p></blockquote><h3 id="MySQL分表"><a href="#MySQL分表" class="headerlink" title="MySQL分表"></a><strong>MySQL分表</strong></h3><p>分表有两种分割方式，一种垂直拆分，另一种水平拆分。</p><ul><li><p><strong>垂直拆分</strong> 垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。</p></li><li><p>水平拆分(数据分片)</p><p>单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。 水平分割的几种方法：</p><ul><li>使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。</li><li>还可根据时间放入不同的表，比如：article_201601，article_201602。</li><li>按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。</li><li>根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。</li></ul></li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/vl4k68clhq.jpeg?imageView2/2/w/1620" alt="img"></p><h3 id="MySQL分库"><a href="#MySQL分库" class="headerlink" title="MySQL分库"></a><strong>MySQL分库</strong></h3><blockquote><p>❝为什么要分库?</p></blockquote><p>数据库集群环境后都是多台 slave，基本满足了读取操作;  但是写入或者说<a href="https://cloud.tencent.com/solution/bigdata?from=10680">大数据</a>、频繁的写入操作对master性能影响就比较大，这个时候，单库并不能解决大规模并发写入的问题，所以就会考虑分库。</p><blockquote><p>❝分库是什么？</p></blockquote><p>一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。</p><p>优点：</p><ul><li>减少增量数据写入时的锁对查询的影响</li><li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短</li></ul><p>但是它无法解决单表数据量太大的问题</p><p><strong>分库分表后的难题</strong></p><p>分布式事务的问题，数据的完整性和一致性问题。</p><p>数据操作维度问题：用户、交易、订单各个不同的维度，用户查询维度、产品数据分析维度的不同对比分析角度。跨库联合查询的问题，可能需要两次查询 跨节点的count、order by、group by以及聚合函数问题，可能需要分别在各个节点上得到结果后在应用程序端进行合并 额外的数据管理负担，如：访问数据表的导航定位 额外的数据运算压力，如：需要在多个节点执行，然后再合并计算程序编码开发难度提升，没有太好的框架解决，更多依赖业务看如何分，如何合，是个难题。</p><blockquote><p>❝配主从，正经公司的话，也不会让 Javaer 去搞的，但还是要知道</p></blockquote><h2 id="十、主从复制"><a href="#十、主从复制" class="headerlink" title="十、主从复制"></a><strong>十、主从复制</strong></h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a><strong>复制的基本原理</strong></h3><ul><li>slave 会从 master 读取 binlog 来进行数据同步</li><li>三个步骤</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-2947935/bdu52dc3z5.jpeg?imageView2/2/w/1620" alt="img"></p><p>img</p><ol><li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；</li><li>salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;</li><li>slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。</li></ol><h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a><strong>复制的基本原则</strong></h3><ul><li>每个 slave只有一个 master</li><li>每个 salve只能有一个唯一的服务器 ID</li><li>每个master可以有多个salve</li></ul><h3 id="复制的最大问题"><a href="#复制的最大问题" class="headerlink" title="复制的最大问题"></a><strong>复制的最大问题</strong></h3><ul><li>延时</li></ul><h2 id="十一、其他问题"><a href="#十一、其他问题" class="headerlink" title="十一、其他问题"></a><strong>十一、其他问题</strong></h2><h3 id="说一说三个范式"><a href="#说一说三个范式" class="headerlink" title="说一说三个范式"></a><strong>说一说三个范式</strong></h3><ul><li>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</li><li>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</li><li>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系：关键字段 → 非关键字段 x → 非关键字段y</li></ul><h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a><strong>百万级别或以上的数据如何删除</strong></h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增&#x2F;改&#x2F;删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><ol><li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li><li>然后删除其中无用数据（此过程需要不到两分钟）</li><li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li><li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实现分布式锁</title>
    <link href="/2022/06/29/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2022/06/29/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。</p></blockquote><h3 id="1-可靠性"><a href="#1-可靠性" class="headerlink" title="1.可靠性"></a>1.可靠性</h3><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ol><li><strong>互斥性。</strong>在任意时刻，只有一个客户端能持有锁。</li><li><strong>不会发生死锁。</strong>即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li><strong>具有容错性。</strong>只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li><li><strong>解铃还须系铃人。</strong>加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li></ol><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTool</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOCK_SUCCESS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SET_IF_NOT_EXIST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;NX&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SET_WITH_EXPIRE_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;PX&quot;</span>;<br><br>    <span class="hljs-comment">/** * 尝试获取分布式锁 * <span class="hljs-doctag">@param</span> jedis Redis客户端 * <span class="hljs-doctag">@param</span> lockKey 锁 * <span class="hljs-doctag">@param</span> requestId 请求标识 * <span class="hljs-doctag">@param</span> expireTime 超期时间 * <span class="hljs-doctag">@return</span> 是否获取成功 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryGetDistributedLock</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId, <span class="hljs-type">int</span> expireTime)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);<br><br>        <span class="hljs-keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：</p><ul><li>第一个为key，我们使用key来当锁，因为key是唯一的。</li><li>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件<strong>解铃还须系铃人</strong>，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。</li><li>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li><li>第五个为time，与第四个参数相呼应，代表key的过期时间。</li></ul><p><strong>总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作</strong>。</p><p>心细的童鞋就会发现了，我们的加锁代码满足我们<strong>可靠性</strong>里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p><p><strong>解锁：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTool</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">Long</span> <span class="hljs-variable constant_">RELEASE_SUCCESS</span> = 1L;<br><br>    <span class="hljs-comment">/** * 释放分布式锁 * <span class="hljs-doctag">@param</span> jedis Redis客户端 * <span class="hljs-doctag">@param</span> lockKey 锁 * <span class="hljs-doctag">@param</span> requestId 请求标识 * <span class="hljs-doctag">@return</span> 是否释放成功 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">releaseDistributedLock</span>(<span class="hljs-params">Jedis jedis, <span class="hljs-built_in">String</span> lockKey, <span class="hljs-built_in">String</span> requestId</span>) &#123;<br><br>        <span class="hljs-title class_">String</span> script = <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;<br>        <span class="hljs-title class_">Object</span> result = jedis.<span class="hljs-built_in">eval</span>(script, <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">singletonList</span>(lockKey), <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">singletonList</span>(requestId));<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">RELEASE_SUCCESS</span>.<span class="hljs-title function_">equals</span>(result)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。</p><p>那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：”简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。”</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IntelliJ IDEA for Windows 快捷键整理</title>
    <link href="/2022/06/29/IntelliJ-IDEA-for-Windows-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/"/>
    <url>/2022/06/29/IntelliJ-IDEA-for-Windows-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Ctrl"><a href="#1-Ctrl" class="headerlink" title="1.Ctrl"></a>1.Ctrl</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + F</td><td align="left">在当前文件进行文本查找 （必备）</td></tr><tr><td align="left">Ctrl + R</td><td align="left">在当前文件进行文本替换 （必备）</td></tr><tr><td align="left">Ctrl + Z</td><td align="left">撤销 （必备）</td></tr><tr><td align="left">Ctrl + Y</td><td align="left">删除光标所在行 或 删除选中的行 （必备）</td></tr><tr><td align="left">Ctrl + X</td><td align="left">剪切光标所在行 或 剪切选择内容</td></tr><tr><td align="left">Ctrl + C</td><td align="left">复制光标所在行 或 复制选择内容</td></tr><tr><td align="left">Ctrl + D</td><td align="left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</td></tr><tr><td align="left">Ctrl + W</td><td align="left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）</td></tr><tr><td align="left">Ctrl + E</td><td align="left">显示最近打开的文件记录列表</td></tr><tr><td align="left">Ctrl + N</td><td align="left">根据输入的 类名 查找类文件</td></tr><tr><td align="left">Ctrl + G</td><td align="left">在当前文件跳转到指定行处</td></tr><tr><td align="left">Ctrl + J</td><td align="left">插入自定义动态代码模板</td></tr><tr><td align="left">Ctrl + P</td><td align="left">方法参数提示显示</td></tr><tr><td align="left">Ctrl + Q</td><td align="left">光标所在的变量 &#x2F; 类名 &#x2F; 方法名等上面（也可以在提示补充的时候按），显示文档内容</td></tr><tr><td align="left">Ctrl + U</td><td align="left">前往当前光标所在的方法的父类的方法 &#x2F; 接口定义</td></tr><tr><td align="left">Ctrl + B</td><td align="left">进入光标所在的方法&#x2F;变量的接口或是定义出，等效于 Ctrl + 左键单击</td></tr><tr><td align="left">Ctrl + K</td><td align="left">版本控制提交项目，需要此项目有加入到版本控制才可用</td></tr><tr><td align="left">Ctrl + T</td><td align="left">版本控制更新项目，需要此项目有加入到版本控制才可用</td></tr><tr><td align="left">Ctrl + H</td><td align="left">显示当前类的层次结构</td></tr><tr><td align="left">Ctrl + O</td><td align="left">选择可重写的方法</td></tr><tr><td align="left">Ctrl + I</td><td align="left">选择可继承的方法</td></tr><tr><td align="left">Ctrl + +</td><td align="left">展开代码</td></tr><tr><td align="left">Ctrl + -</td><td align="left">折叠代码</td></tr><tr><td align="left">Ctrl + &#x2F;</td><td align="left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）</td></tr><tr><td align="left">Ctrl + [</td><td align="left">移动光标到当前所在代码的花括号开始位置</td></tr><tr><td align="left">Ctrl + ]</td><td align="left">移动光标到当前所在代码的花括号结束位置</td></tr><tr><td align="left">Ctrl + F1</td><td align="left">在光标所在的错误代码出显示错误信息</td></tr><tr><td align="left">Ctrl + F3</td><td align="left">调转到所选中的词的下一个引用位置</td></tr><tr><td align="left">Ctrl + F4</td><td align="left">关闭当前编辑文件</td></tr><tr><td align="left">Ctrl + F8</td><td align="left">在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td></tr><tr><td align="left">Ctrl + F9</td><td align="left">执行 Make Project 操作</td></tr><tr><td align="left">Ctrl + F11</td><td align="left">选中文件 &#x2F; 文件夹，使用助记符设定 &#x2F; 取消书签</td></tr><tr><td align="left">Ctrl + F12</td><td align="left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td></tr><tr><td align="left">Ctrl + Tab</td><td align="left">编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td></tr><tr><td align="left">Ctrl + Enter</td><td align="left">智能分隔行</td></tr><tr><td align="left">Ctrl + End</td><td align="left">跳到文件尾</td></tr><tr><td align="left">Ctrl + Home</td><td align="left">跳到文件头</td></tr><tr><td align="left">Ctrl + Space</td><td align="left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备）</td></tr><tr><td align="left">Ctrl + Delete</td><td align="left">删除光标后面的单词或是中文句</td></tr><tr><td align="left">Ctrl + BackSpace</td><td align="left">删除光标前面的单词或是中文句</td></tr><tr><td align="left">Ctrl + 1,2,3…9</td><td align="left">定位到对应数值的书签位置</td></tr><tr><td align="left">Ctrl + 左键单击</td><td align="left">在打开的文件标题上，弹出该文件路径</td></tr><tr><td align="left">Ctrl + 光标定位</td><td align="left">按 Ctrl 不要松开，会显示光标所在的类信息摘要</td></tr><tr><td align="left">Ctrl + 左方向键</td><td align="left">光标跳转到当前单词 &#x2F; 中文句的左侧开头位置</td></tr><tr><td align="left">Ctrl + 右方向键</td><td align="left">光标跳转到当前单词 &#x2F; 中文句的右侧开头位置</td></tr><tr><td align="left">Ctrl + 前方向键</td><td align="left">等效于鼠标滚轮向前效果</td></tr><tr><td align="left">Ctrl + 后方向键</td><td align="left">等效于鼠标滚轮向后效果</td></tr></tbody></table><h3 id="2-Alt"><a href="#2-Alt" class="headerlink" title="2.Alt"></a>2.Alt</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Alt + &#96;</td><td align="left">显示版本控制常用操作菜单弹出层</td></tr><tr><td align="left">Alt + Q</td><td align="left">弹出一个提示，显示当前类的声明 &#x2F; 上下文信息</td></tr><tr><td align="left">Alt + F1</td><td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td></tr><tr><td align="left">Alt + F2</td><td align="left">对于前面页面，显示各类浏览器打开目标选择弹出层</td></tr><tr><td align="left">Alt + F3</td><td align="left">选中文本，逐个往下查找相同文本，并高亮显示</td></tr><tr><td align="left">Alt + F7</td><td align="left">查找光标所在的方法 &#x2F; 变量 &#x2F; 类被调用的地方</td></tr><tr><td align="left">Alt + F8</td><td align="left">在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td></tr><tr><td align="left">Alt + Home</td><td align="left">定位 &#x2F; 显示到当前文件的 Navigation Bar</td></tr><tr><td align="left">Alt + Enter</td><td align="left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）</td></tr><tr><td align="left">Alt + Insert</td><td align="left">代码自动生成，如生成对象的 set &#x2F; get 方法，构造函数，toString() 等</td></tr><tr><td align="left">Alt + 左方向键</td><td align="left">按左方向切换当前已打开的文件视图</td></tr><tr><td align="left">Alt + 右方向键</td><td align="left">按右方向切换当前已打开的文件视图</td></tr><tr><td align="left">Alt + 前方向键</td><td align="left">当前光标跳转到当前文件的前一个方法名位置</td></tr><tr><td align="left">Alt + 后方向键</td><td align="left">当前光标跳转到当前文件的后一个方法名位置</td></tr><tr><td align="left">Alt + 1,2,3…9</td><td align="left">显示对应数值的选项卡，其中 1 是 Project 用得最多</td></tr></tbody></table><h3 id="3-Shift"><a href="#3-Shift" class="headerlink" title="3.Shift"></a>3.Shift</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Shift + F1</td><td align="left">如果有外部文档可以连接外部文档</td></tr><tr><td align="left">Shift + F2</td><td align="left">跳转到上一个高亮错误 或 警告位置</td></tr><tr><td align="left">Shift + F3</td><td align="left">在查找模式下，查找匹配上一个</td></tr><tr><td align="left">Shift + F4</td><td align="left">对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td></tr><tr><td align="left">Shift + F6</td><td align="left">对文件 &#x2F; 文件夹 重命名</td></tr><tr><td align="left">Shift + F7</td><td align="left">在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td></tr><tr><td align="left">Shift + F8</td><td align="left">在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</td></tr><tr><td align="left">Shift + F9</td><td align="left">等效于点击工具栏的 Debug 按钮</td></tr><tr><td align="left">Shift + F10</td><td align="left">等效于点击工具栏的 Run 按钮</td></tr><tr><td align="left">Shift + F11</td><td align="left">弹出书签显示层</td></tr><tr><td align="left">Shift + Tab</td><td align="left">取消缩进</td></tr><tr><td align="left">Shift + ESC</td><td align="left">隐藏当前 或 最后一个激活的工具窗口</td></tr><tr><td align="left">Shift + End</td><td align="left">选中光标到当前行尾位置</td></tr><tr><td align="left">Shift + Home</td><td align="left">选中光标到当前行头位置</td></tr><tr><td align="left">Shift + Enter</td><td align="left">开始新一行。光标所在行下空出一行，光标定位到新行位置</td></tr><tr><td align="left">Shift + 左键单击</td><td align="left">在打开的文件名上按此快捷键，可以关闭当前打开文件</td></tr><tr><td align="left">Shift + 滚轮前后滚动</td><td align="left">当前文件的横向滚动轴滚动</td></tr></tbody></table><h3 id="4-Ctrl-Alt"><a href="#4-Ctrl-Alt" class="headerlink" title="4.Ctrl + Alt"></a>4.Ctrl + Alt</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Alt + L</td><td align="left">格式化代码，可以对当前文件和整个包目录使用 （必备）</td></tr><tr><td align="left">Ctrl + Alt + O</td><td align="left">优化导入的类，可以对当前文件和整个包目录使用 （必备）</td></tr><tr><td align="left">Ctrl + Alt + I</td><td align="left">光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td></tr><tr><td align="left">Ctrl + Alt + T</td><td align="left">对选中的代码弹出环绕选项弹出层</td></tr><tr><td align="left">Ctrl + Alt + J</td><td align="left">弹出模板选择窗口，讲选定的代码加入动态模板中</td></tr><tr><td align="left">Ctrl + Alt + H</td><td align="left">调用层次</td></tr><tr><td align="left">Ctrl + Alt + B</td><td align="left">在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td></tr><tr><td align="left">Ctrl + Alt + V</td><td align="left">快速引进变量</td></tr><tr><td align="left">Ctrl + Alt + Y</td><td align="left">同步、刷新</td></tr><tr><td align="left">Ctrl + Alt + S</td><td align="left">打开 IntelliJ IDEA 系统设置</td></tr><tr><td align="left">Ctrl + Alt + F7</td><td align="left">显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td></tr><tr><td align="left">Ctrl + Alt + F11</td><td align="left">切换全屏模式</td></tr><tr><td align="left">Ctrl + Alt + Enter</td><td align="left">光标所在行上空出一行，光标定位到新行</td></tr><tr><td align="left">Ctrl + Alt + Home</td><td align="left">弹出跟当前文件有关联的文件弹出层</td></tr><tr><td align="left">Ctrl + Alt + Space</td><td align="left">类名自动完成</td></tr><tr><td align="left">Ctrl + Alt + 左方向键</td><td align="left">退回到上一个操作的地方 （必备）<strong>（注意与其他软件快捷键冲突）</strong></td></tr><tr><td align="left">Ctrl + Alt + 右方向键</td><td align="left">前进到上一个操作的地方 （必备）<strong>（注意与其他软件快捷键冲突）</strong></td></tr><tr><td align="left">Ctrl + Alt + 前方向键</td><td align="left">在查找模式下，跳到上个查找的文件</td></tr><tr><td align="left">Ctrl + Alt + 后方向键</td><td align="left">在查找模式下，跳到下个查找的文件</td></tr></tbody></table><h3 id="5-Ctrl-Shift"><a href="#5-Ctrl-Shift" class="headerlink" title="5.Ctrl + Shift"></a>5.Ctrl + Shift</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Shift + F</td><td align="left">根据输入内容查找整个项目 或 指定目录内文件 （必备）</td></tr><tr><td align="left">Ctrl + Shift + R</td><td align="left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）</td></tr><tr><td align="left">Ctrl + Shift + J</td><td align="left">自动将下一行合并到当前行末尾 （必备）</td></tr><tr><td align="left">Ctrl + Shift + Z</td><td align="left">取消撤销 （必备）</td></tr><tr><td align="left">Ctrl + Shift + W</td><td align="left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）</td></tr><tr><td align="left">Ctrl + Shift + N</td><td align="left">通过文件名定位 &#x2F; 打开文件 &#x2F; 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）</td></tr><tr><td align="left">Ctrl + Shift + U</td><td align="left">对选中的代码进行大 &#x2F; 小写轮流转换 （必备）</td></tr><tr><td align="left">Ctrl + Shift + T</td><td align="left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td></tr><tr><td align="left">Ctrl + Shift + C</td><td align="left">复制当前文件磁盘路径到剪贴板</td></tr><tr><td align="left">Ctrl + Shift + V</td><td align="left">弹出缓存的最近拷贝的内容管理器弹出层</td></tr><tr><td align="left">Ctrl + Shift + E</td><td align="left">显示最近修改的文件列表的弹出层</td></tr><tr><td align="left">Ctrl + Shift + H</td><td align="left">显示方法层次结构</td></tr><tr><td align="left">Ctrl + Shift + B</td><td align="left">跳转到类型声明处</td></tr><tr><td align="left">Ctrl + Shift + I</td><td align="left">快速查看光标所在的方法 或 类的定义</td></tr><tr><td align="left">Ctrl + Shift + A</td><td align="left">查找动作 &#x2F; 设置</td></tr><tr><td align="left">Ctrl + Shift + &#x2F;</td><td align="left">代码块注释 （必备）</td></tr><tr><td align="left">Ctrl + Shift + [</td><td align="left">选中从光标所在位置到它的顶部中括号位置</td></tr><tr><td align="left">Ctrl + Shift + ]</td><td align="left">选中从光标所在位置到它的底部中括号位置</td></tr><tr><td align="left">Ctrl + Shift + +</td><td align="left">展开所有代码</td></tr><tr><td align="left">Ctrl + Shift + -</td><td align="left">折叠所有代码</td></tr><tr><td align="left">Ctrl + Shift + F7</td><td align="left">高亮显示所有该选中文本，按Esc高亮消失</td></tr><tr><td align="left">Ctrl + Shift + F8</td><td align="left">在 Debug 模式下，指定断点进入条件</td></tr><tr><td align="left">Ctrl + Shift + F9</td><td align="left">编译选中的文件 &#x2F; 包 &#x2F; Module</td></tr><tr><td align="left">Ctrl + Shift + F12</td><td align="left">编辑器最大化</td></tr><tr><td align="left">Ctrl + Shift + Space</td><td align="left">智能代码提示</td></tr><tr><td align="left">Ctrl + Shift + Enter</td><td align="left">自动结束代码，行末自动添加分号 （必备）</td></tr><tr><td align="left">Ctrl + Shift + Backspace</td><td align="left">退回到上次修改的地方</td></tr><tr><td align="left">Ctrl + Shift + 1,2,3…9</td><td align="left">快速添加指定数值的书签</td></tr><tr><td align="left">Ctrl + Shift + 左方向键</td><td align="left">在代码文件上，光标跳转到当前单词 &#x2F; 中文句的左侧开头位置，同时选中该单词 &#x2F; 中文句</td></tr><tr><td align="left">Ctrl + Shift + 右方向键</td><td align="left">在代码文件上，光标跳转到当前单词 &#x2F; 中文句的右侧开头位置，同时选中该单词 &#x2F; 中文句</td></tr><tr><td align="left">Ctrl + Shift + 左方向键</td><td align="left">在光标焦点是在工具选项卡上，缩小选项卡区域</td></tr><tr><td align="left">Ctrl + Shift + 右方向键</td><td align="left">在光标焦点是在工具选项卡上，扩大选项卡区域</td></tr><tr><td align="left">Ctrl + Shift + 前方向键</td><td align="left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td></tr><tr><td align="left">Ctrl + Shift + 后方向键</td><td align="left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td></tr></tbody></table><h3 id="6-Alt-Shift"><a href="#6-Alt-Shift" class="headerlink" title="6.Alt + Shift"></a>6.Alt + Shift</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Alt + Shift + N</td><td align="left">选择 &#x2F; 添加 task</td></tr><tr><td align="left">Alt + Shift + F</td><td align="left">显示添加到收藏夹弹出层</td></tr><tr><td align="left">Alt + Shift + C</td><td align="left">查看最近操作项目的变化情况列表</td></tr><tr><td align="left">Alt + Shift + F</td><td align="left">添加到收藏夹</td></tr><tr><td align="left">Alt + Shift + I</td><td align="left">查看项目当前文件</td></tr><tr><td align="left">Alt + Shift + F7</td><td align="left">在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td></tr><tr><td align="left">Alt + Shift + F9</td><td align="left">弹出 Debug 的可选择菜单</td></tr><tr><td align="left">Alt + Shift + F10</td><td align="left">弹出 Run 的可选择菜单</td></tr><tr><td align="left">Alt + Shift + 左键双击</td><td align="left">选择被双击的单词 &#x2F; 中文句，按住不放，可以同时选择其他单词 &#x2F; 中文句</td></tr><tr><td align="left">Alt + Shift + 前方向键</td><td align="left">移动光标所在行向上移动</td></tr><tr><td align="left">Alt + Shift + 后方向键</td><td align="left">移动光标所在行向下移动</td></tr></tbody></table><h3 id="7-Ctrl-Shift-Alt"><a href="#7-Ctrl-Shift-Alt" class="headerlink" title="7.Ctrl + Shift + Alt"></a>7.Ctrl + Shift + Alt</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Shift + Alt + V</td><td align="left">无格式黏贴</td></tr><tr><td align="left">Ctrl + Shift + Alt + N</td><td align="left">前往指定的变量 &#x2F; 方法</td></tr><tr><td align="left">Ctrl + Shift + Alt + S</td><td align="left">打开当前项目设置</td></tr><tr><td align="left">Ctrl + Shift + Alt + C</td><td align="left">复制参考信息</td></tr></tbody></table><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8.其他"></a>8.其他</h3><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">F2</td><td align="left">跳转到下一个高亮错误 或 警告位置 （必备）</td></tr><tr><td align="left">F3</td><td align="left">在查找模式下，定位到下一个匹配处</td></tr><tr><td align="left">F4</td><td align="left">编辑源</td></tr><tr><td align="left">F7</td><td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td></tr><tr><td align="left">F8</td><td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td></tr><tr><td align="left">F9</td><td align="left">在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td></tr><tr><td align="left">F11</td><td align="left">添加书签</td></tr><tr><td align="left">F12</td><td align="left">回到前一个工具窗口</td></tr><tr><td align="left">Tab</td><td align="left">缩进</td></tr><tr><td align="left">ESC</td><td align="left">从工具窗口进入代码文件窗口</td></tr><tr><td align="left">连按两次Shift</td><td align="left">弹出 Search Everywhere 弹出层</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea快捷键</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IntelliJ IDEA for Mac 快捷键整理</title>
    <link href="/2022/06/29/IntelliJ-IDEA-for-Mac-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/"/>
    <url>/2022/06/29/IntelliJ-IDEA-for-Mac-%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Editing（编辑）"><a href="#1-Editing（编辑）" class="headerlink" title="1.Editing（编辑）"></a>1.Editing（编辑）</h3><table><thead><tr><th align="left">No.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Command+Shift+Enter</td><td align="left">自动结束代码，行末自动添加分号</td></tr><tr><td align="left">2</td><td align="left">Command+P</td><td align="left">显示方法的参数详情</td></tr><tr><td align="left">3</td><td align="left">Control+J</td><td align="left">快速查看文档</td></tr><tr><td align="left">4</td><td align="left">Command+鼠标移上去</td><td align="left">显示代码简要信息</td></tr><tr><td align="left">5</td><td align="left">Command+F1</td><td align="left">在错误或警告处显示具体描述信息</td></tr><tr><td align="left">6</td><td align="left">Command+N</td><td align="left">声称代码</td></tr><tr><td align="left">7</td><td align="left">Control+O</td><td align="left">覆盖方法(重写父类方法)</td></tr><tr><td align="left">8</td><td align="left">Control+I</td><td align="left">实现方法(实现接口中的方法)</td></tr><tr><td align="left">9</td><td align="left">Command+Option+T</td><td align="left">包围代码(使用if…else等包围选中的代码)</td></tr><tr><td align="left">10</td><td align="left">Command+&#x2F;</td><td align="left">注释&#x2F;取消注释与行注释</td></tr><tr><td align="left">11</td><td align="left">Command+Option+&#x2F;</td><td align="left">注释&#x2F;取消注释与块注释</td></tr><tr><td align="left">12</td><td align="left">Option+向上箭头</td><td align="left">连续选中代码块</td></tr><tr><td align="left">13</td><td align="left">Option+向下箭头</td><td align="left">减少当前选中的代码块</td></tr><tr><td align="left">14</td><td align="left">Command+Option+L</td><td align="left">格式化代码</td></tr><tr><td align="left">15</td><td align="left">Control+Option+O</td><td align="left">优化import</td></tr><tr><td align="left">16</td><td align="left">Control+Option+I</td><td align="left">自动缩进线</td></tr><tr><td align="left">17</td><td align="left">Tab</td><td align="left">缩进代码</td></tr><tr><td align="left">18</td><td align="left">Shift+Tab</td><td align="left">反缩进代码</td></tr><tr><td align="left">19</td><td align="left">Command+X</td><td align="left">剪切当前行或选中的块到剪贴板</td></tr><tr><td align="left">20</td><td align="left">Command+C</td><td align="left">复制当前行或选中的块到剪贴板</td></tr><tr><td align="left">21</td><td align="left">Command+V</td><td align="left">从剪贴板粘贴</td></tr><tr><td align="left">22</td><td align="left">Command+Shift+V</td><td align="left">从最近的缓冲区粘贴</td></tr><tr><td align="left">23</td><td align="left">Command+D</td><td align="left">复制当前行或选中的块</td></tr><tr><td align="left">24</td><td align="left">Command+Delete</td><td align="left">删除当前行或选中的块的行</td></tr><tr><td align="left">25</td><td align="left">Control+Shift+J</td><td align="left">智能地将代码拼接成一行</td></tr><tr><td align="left">26</td><td align="left">Shift+Enter</td><td align="left">开始新的一行</td></tr><tr><td align="left">27</td><td align="left">Command+Shift+U</td><td align="left">大小写切换</td></tr><tr><td align="left">28</td><td align="left">Option+Fn+Delete</td><td align="left">删除到单词末尾</td></tr><tr><td align="left">29</td><td align="left">Option+Delete</td><td align="left">删除到单词开始</td></tr><tr><td align="left">30</td><td align="left">Command+‘+’&#x2F;‘-’</td><td align="left">展开&#x2F;折叠代码块</td></tr><tr><td align="left">31</td><td align="left">Command+Shift+‘+’</td><td align="left">展开所有代码块</td></tr><tr><td align="left">32</td><td align="left">Command+Shift+‘-’</td><td align="left">折叠所有代码块</td></tr><tr><td align="left">33</td><td align="left">Command+W</td><td align="left">关闭活动的编辑器选项卡</td></tr></tbody></table><h3 id="2-Search-x2F-Replace-查询-x2F-替换"><a href="#2-Search-x2F-Replace-查询-x2F-替换" class="headerlink" title="2.Search&#x2F;Replace (查询&#x2F;替换)"></a>2.Search&#x2F;Replace (查询&#x2F;替换)</h3><table><thead><tr><th align="left">快捷键</th><th align="left">描述</th><th></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Double Shift</td><td>查询任何东西</td></tr><tr><td align="left">2</td><td align="left">Command+F</td><td>文件内查找</td></tr><tr><td align="left">3</td><td align="left">Command+G</td><td>查找模式下，向下查找</td></tr><tr><td align="left">4</td><td align="left">Command+Shift+G</td><td>查找模式下，向上查找</td></tr><tr><td align="left">5</td><td align="left">Command+R</td><td>文件内替换</td></tr><tr><td align="left">6</td><td align="left">Command+Shift+F</td><td>全局查找(根据路径)</td></tr><tr><td align="left">7</td><td align="left">Command+Shift+R</td><td>全局替换(根据路径)</td></tr></tbody></table><h3 id="3-Usage-Search-使用查询"><a href="#3-Usage-Search-使用查询" class="headerlink" title="3.Usage Search (使用查询)"></a>3.Usage Search (使用查询)</h3><table><thead><tr><th align="left">快捷键</th><th align="left">描述</th><th></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Option+F7</td><td>在文件中查找用法</td></tr><tr><td align="left">2</td><td align="left">Command+F7</td><td>在类中查找用法</td></tr><tr><td align="left">3</td><td align="left">Command+Shift+F7</td><td>在文件中突出显示的用法</td></tr></tbody></table><h3 id="4-Compile-and-Run-编译和运行"><a href="#4-Compile-and-Run-编译和运行" class="headerlink" title="4.Compile and Run (编译和运行)"></a>4.Compile and Run (编译和运行)</h3><table><thead><tr><th align="left">o.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Command+F9</td><td align="left">编译项目</td></tr><tr><td align="left">2</td><td align="left">Command+Shift+F9</td><td align="left">编译选中的文件、包或模块</td></tr><tr><td align="left">3</td><td align="left">Control+Option+R</td><td align="left">弹出Run的可选择菜单</td></tr><tr><td align="left">4</td><td align="left">Control+Option+D</td><td align="left">弹出Debug的可选择菜单</td></tr><tr><td align="left">5</td><td align="left">Control+R</td><td align="left">运行</td></tr><tr><td align="left">6</td><td align="left">Control+D</td><td align="left">调试</td></tr><tr><td align="left">7</td><td align="left">Control+Shift+R</td><td align="left">从编辑器运行上下文环境配置</td></tr><tr><td align="left">8</td><td align="left">Control+Shift+D</td><td align="left">从编辑器运行上下文环境配置</td></tr></tbody></table><h3 id="5-Debugging-调试"><a href="#5-Debugging-调试" class="headerlink" title="5.Debugging (调试)"></a>5.Debugging (调试)</h3><table><thead><tr><th align="left">o.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">F8</td><td align="left">进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td></tr><tr><td align="left">2</td><td align="left">F7</td><td align="left">进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td></tr><tr><td align="left">3</td><td align="left">Shift+F7</td><td align="left">智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法</td></tr><tr><td align="left">4</td><td align="left">Shift+F8</td><td align="left">跳出</td></tr><tr><td align="left">5</td><td align="left">Control+F9</td><td align="left">运行到光标处，如果光标前有其他断点会进入到该断点</td></tr><tr><td align="left">6</td><td align="left">Control+F8</td><td align="left">计算表达式(可以更改变量值使其生效)</td></tr><tr><td align="left">7</td><td align="left">Command+Control+R</td><td align="left">恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上</td></tr><tr><td align="left">8</td><td align="left">Command+F8</td><td align="left">切换断点(若光标当前行有断点则取消断点，没有则加上断点)</td></tr><tr><td align="left">9</td><td align="left">Command+Shift+F8</td><td align="left">查看断点信息</td></tr></tbody></table><h3 id="6-Navigation-导航"><a href="#6-Navigation-导航" class="headerlink" title="6.Navigation (导航)"></a>6.Navigation (导航)</h3><table><thead><tr><th align="left">No.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Command+O</td><td align="left">查找类文件</td></tr><tr><td align="left">2</td><td align="left">Command+Shift+O</td><td align="left">查找所类型文件</td></tr><tr><td align="left">3</td><td align="left">Command+Shift+[&#x2F;]</td><td align="left">切换标签页</td></tr><tr><td align="left">4</td><td align="left">Esc</td><td align="left">从工具窗口进入到代码窗口</td></tr><tr><td align="left">5</td><td align="left">Command+L</td><td align="left">在当前文件跳转到某一行的指定处</td></tr><tr><td align="left">6</td><td align="left">Command+E</td><td align="left">显示最近打开的文件记录列表</td></tr><tr><td align="left">7</td><td align="left">Command+Option+向左箭头&#x2F;向右箭头</td><td align="left">退回&#x2F;前进到上一个操作的位置</td></tr><tr><td align="left">8</td><td align="left">Command+Shift+Delete</td><td align="left">跳转到最后一个编辑的地方</td></tr><tr><td align="left">9</td><td align="left">Option+F1</td><td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td></tr><tr><td align="left">10</td><td align="left">Command+B&#x2F;鼠标点击</td><td align="left">进入光标所在的方法&#x2F;变量的接口或是定义处</td></tr><tr><td align="left">11</td><td align="left">Command+Option+B&#x2F;鼠标点击</td><td align="left">跳转到实现处</td></tr><tr><td align="left">12</td><td align="left">Option+Space&#x2F;Command+Y</td><td align="left">快速打开光标所在方法、类的定义</td></tr><tr><td align="left">13</td><td align="left">Control+Shift+B</td><td align="left">跳转到类型声明处</td></tr><tr><td align="left">14</td><td align="left">Command+U</td><td align="left">前往当前光标所在方法的父类的方法&#x2F;接口定义</td></tr><tr><td align="left">15</td><td align="left">Command+F12</td><td align="left">弹出当前文件结构层</td></tr><tr><td align="left">16</td><td align="left">Control+H</td><td align="left">显示当前类的层次结构</td></tr><tr><td align="left">17</td><td align="left">Control+Option+H</td><td align="left">显示调用层次结构</td></tr><tr><td align="left">18</td><td align="left">F2&#x2F;Shift+F2</td><td align="left">跳转到上一个&#x2F;下一个突出错误或者警告的位置</td></tr><tr><td align="left">19</td><td align="left">F4</td><td align="left">编辑查看代码源</td></tr><tr><td align="left">20</td><td align="left">Option+F3</td><td align="left">选中文件&#x2F;文件夹&#x2F;代码行，使用助记符添加&#x2F;取消书签</td></tr><tr><td align="left">21</td><td align="left">Command+F3</td><td align="left">显示所有标签</td></tr></tbody></table><h3 id="7-Refactoring-重构"><a href="#7-Refactoring-重构" class="headerlink" title="7.Refactoring (重构)"></a>7.Refactoring (重构)</h3><table><thead><tr><th align="left">.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">F5</td><td align="left">复制文件到指定目录</td></tr><tr><td align="left">2</td><td align="left">F6</td><td align="left">移动文件到指定目录</td></tr><tr><td align="left">3</td><td align="left">Command+Delete</td><td align="left">在文件上为安全删除文件，弹出确认框</td></tr><tr><td align="left">4</td><td align="left">Shift+F6</td><td align="left">重命名文件</td></tr><tr><td align="left">5</td><td align="left">Command+F6</td><td align="left">更改签名</td></tr><tr><td align="left">6</td><td align="left">Command+Option+M</td><td align="left">将选中的代码提取为方法</td></tr><tr><td align="left">7</td><td align="left">Command+Option+V</td><td align="left">提取变量</td></tr><tr><td align="left">8</td><td align="left">Command+Option+F</td><td align="left">提取字段</td></tr><tr><td align="left">9</td><td align="left">Command+Option+C</td><td align="left">提取常量</td></tr><tr><td align="left">10</td><td align="left">Command+Option+P</td><td align="left">提取参数</td></tr></tbody></table><h3 id="8-VCS-x2F-Local-History-版本控制-x2F-本地历史记录"><a href="#8-VCS-x2F-Local-History-版本控制-x2F-本地历史记录" class="headerlink" title="8.VCS&#x2F;Local History (版本控制&#x2F;本地历史记录)"></a>8.VCS&#x2F;Local History (版本控制&#x2F;本地历史记录)</h3><table><thead><tr><th align="left">快捷键</th><th align="left">描述</th><th></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Command+K</td><td>提交代码到版本控制器</td></tr><tr><td align="left">2</td><td align="left">Command+T</td><td>从版本控制器更新代码</td></tr><tr><td align="left">3</td><td align="left">Option+Shift+C</td><td>查看最近的变更记录</td></tr></tbody></table><h3 id="9-Live-Templates-动态模板"><a href="#9-Live-Templates-动态模板" class="headerlink" title="9.Live Templates (动态模板)"></a>9.Live Templates (动态模板)</h3><table><thead><tr><th align="left">快捷键</th><th align="left">描述</th><th></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Command+Option+J</td><td>弹出模板选择窗口，将选定的代码使用动态模板包住</td></tr><tr><td align="left">2</td><td align="left">Command+J</td><td>插入自定义动态代码模板</td></tr></tbody></table><h3 id="10-General-通用"><a href="#10-General-通用" class="headerlink" title="10.General (通用)"></a>10.General (通用)</h3><table><thead><tr><th align="left">快捷键</th><th align="left"></th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">打开相应编号的工具窗口</td><td align="left">Command+1…Command+9</td></tr><tr><td align="left">2</td><td align="left">保存所有</td><td align="left">Command+S</td></tr><tr><td align="left">3</td><td align="left">切换全屏模式</td><td align="left">Command+Control+F</td></tr><tr><td align="left">4</td><td align="left">切换最大化编辑器</td><td align="left">Command+Shift+F12</td></tr><tr><td align="left">5</td><td align="left">添加到收藏夹</td><td align="left">Option+Shift+F</td></tr><tr><td align="left">6</td><td align="left">检查当前文件与当前的配置文件</td><td align="left">Option+Shift+I</td></tr><tr><td align="left">7</td><td align="left">打开IDEA系统设置</td><td align="left">Command+,</td></tr><tr><td align="left">8</td><td align="left">打开项目结构对话框</td><td align="left">Command+;</td></tr><tr><td align="left">9</td><td align="left">查找动作</td><td align="left">Command+Shift+A</td></tr><tr><td align="left">10</td><td align="left">编辑窗口和工具窗口之间切换</td><td align="left">Control+Tab</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea快捷键</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell-数值与字符串比较</title>
    <link href="/2022/06/28/shell-%E6%95%B0%E5%80%BC%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/"/>
    <url>/2022/06/28/shell-%E6%95%B0%E5%80%BC%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h3 id="1-只适用于数值的比较"><a href="#1-只适用于数值的比较" class="headerlink" title="1.只适用于数值的比较"></a><strong>1.只适用于数值的比较</strong></h3><p>该类型操作会把两边变量当成整型进行加减运算，字符串abcd按整型运算无法进行，所以此类型不能用于字符串比较</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>等于则为真</td></tr><tr><td>-ne</td><td>不等于则为真</td></tr><tr><td>-gt</td><td>大于则为真</td></tr><tr><td>-ge</td><td>大于等于则为真</td></tr><tr><td>-lt</td><td>小于则为真</td></tr><tr><td>-le</td><td>小于等于则为真</td></tr></tbody></table><h3 id="2-适用于字符串的比较（也可用于数值比较）"><a href="#2-适用于字符串的比较（也可用于数值比较）" class="headerlink" title="2.适用于字符串的比较（也可用于数值比较）"></a><strong>2.适用于字符串的比较（也可用于数值比较）</strong></h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>相等则为真</td></tr><tr><td>!&#x3D;</td><td>不相等则为真</td></tr></tbody></table><h3 id="3-字符串测试运算"><a href="#3-字符串测试运算" class="headerlink" title="3.字符串测试运算"></a><strong>3.字符串测试运算</strong></h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-z 字符串</td><td>字符串的长度为零则为真</td></tr><tr><td>-n 字符串</td><td>字符串的长度不为零则为真</td></tr></tbody></table><h3 id="4-文件测试运算"><a href="#4-文件测试运算" class="headerlink" title="4.文件测试运算"></a><strong>4.文件测试运算</strong></h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e 文件名</td><td>如果文件存在则为真</td></tr><tr><td>-r 文件名</td><td>如果文件存在且可读则为真</td></tr><tr><td>-w 文件名</td><td>如果文件存在且可写则为真</td></tr><tr><td>-x 文件名</td><td>如果文件存在且可执行则为真</td></tr><tr><td>-s 文件名</td><td>如果文件存在且至少有一个字符则为真</td></tr><tr><td>-d 文件名</td><td>如果文件存在且为目录则为真</td></tr><tr><td>-f 文件名</td><td>如果文件存在且为普通文件则为真</td></tr><tr><td>-c 文件名</td><td>如果文件存在且为字符型特殊文件则为真</td></tr><tr><td>-b 文件名</td><td>如果文件存在且为块特殊文件则为真</td></tr></tbody></table><h3 id="5-特殊说明"><a href="#5-特殊说明" class="headerlink" title="5.特殊说明"></a>5.<strong>特殊说明</strong></h3><ol><li><p>在各种运算中，test命令的运算和中括号是等效的</p></li><li><p>赋值时等号两边没空格，比较或测试时运算符两边都要有空格</p></li><li><p>shell默认是字符运算，如果想当数值进行运算要在前边加上expr，如：expr $var1 + $var2</p></li><li><p>shell的文件包含命令只有“.”，而且该命令只能一次包含单个文件（当然可以用*表示文件夹下所有文件）而不能包含一个文件夹；所见的!includedir和#includedir并不存在这样的命令，应该是程序自己实现的包含功能</p></li><li><p>“.”在shell中执行则会影响shell的环境，但如果只在脚本中执行那只影响脚本中的环境不会影响当前shell的环境；source其实也如此。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell比较操作符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java异常类型</title>
    <link href="/2022/06/28/java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/06/28/java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-异常简介"><a href="#1-异常简介" class="headerlink" title="1.异常简介"></a>1.异常简介</h3><p>Java Exception：</p><p>1、Error<br>2、Runtime Exception 运行时异常<br>3、Exception<br>4、throw 用户自定义异常</p><p>异常类分两大类型：Error类代表了编译和系统的错误，不允许捕获；Exception类代表了标准Java库方法所激发的异常。Exception类还包含运行异常类Runtime_Exception和非运行异常类Non_RuntimeException这两个直接的子类。</p><p><strong>运行时异常</strong>类对应于编译错误，它是指Java程序在运行时产生的由解释器引发的各种异常。运行异常可能出现在任何地方，且出现频率很高，因此为了避免巨大的系统资源开销，编译器不对异常进行检查。所以Java语言中的运行异常不一定被捕获。出现运行错误往往表示代码有错误，如：算数异常（如被0除）、下标异常（如数组越界）等。</p><p><strong>非运行时异常</strong>Non_RuntimeException类及其子类的实例，又称为可检测异常。Java编译器利用分析方法或构造方法中可能产生的结果来检测Java程序中是否含有检测异常的处理程序，对于每个可能的可检测异常，方法或构造方法的throws子句必须列出该异常对应的类。在Java的标准包java.lang java.util 和 java.net 中定义的异常都是非运行异常。</p><h3 id="2-常见异常"><a href="#2-常见异常" class="headerlink" title="2.常见异常"></a>2.常见异常</h3><table><thead><tr><th>异常类型</th><th>异常描述</th></tr></thead><tbody><tr><td>ArithmeticExecption</td><td>算术异常类</td></tr><tr><td>NullPointerException</td><td>空指针异常类</td></tr><tr><td>ClassCastException</td><td>类型强制转换异常</td></tr><tr><td>NegativeArrayException</td><td>数组负下标异常</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>数组下标越界异常</td></tr><tr><td>SecturityException</td><td>违背安全原则异常</td></tr><tr><td>EOFException</td><td>文件已结束异常</td></tr><tr><td>FileNotFoundException</td><td>文件未找到异常</td></tr><tr><td>NumberFormatException</td><td>字符串转换为数字异常</td></tr><tr><td>SQLException</td><td>操作数据库异常</td></tr><tr><td>IOException</td><td>输入输出异常</td></tr><tr><td>NoSuchMethodException</td><td>方法未找到异常</td></tr><tr><td>java.lang.AbstractMethodError</td><td>抽象方法错误。当应用试图调用抽象方法时抛出。</td></tr><tr><td>java.lang.AssertionError</td><td>断言错。用来指示一个断言失败的情况。</td></tr><tr><td>java.lang.ClassCircularityError</td><td>类循环依赖错误。在初始化一个类时，若检测到类之间循环依赖则抛出该异常。</td></tr><tr><td>java.lang.ClassFormatError</td><td>类格式错误，当Java虚拟机试图从一个文件中读取Java类，而检测到该文件的内容不符合类的有效格式时抛出</td></tr><tr><td>java.lang.Error</td><td>是所有错误的基类，用于标识严重的程序运行问题</td></tr><tr><td>java.lang.ExceptionInInitializerError</td><td>初始化程序错误。当执行一个类的静态初始化程序的过程中，发生了异常时抛出。静态初始化程序是指直接包含于类中的static语句段</td></tr><tr><td>java.lang.IllegalAccessError</td><td>违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</td></tr><tr><td>java.lang.IncompatibleClassChangeError</td><td>不兼容的类变化错误。当正在执行的方法所依赖的类定义发生了不兼容的改变时，抛出该异常。一般在修改了应用中的某些类的声明定义而没有对整个应用重新编译而直接运行的情况下，容易引发该错误。</td></tr><tr><td>java.lang.InstantiationError</td><td>实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</td></tr><tr><td>java.lang.InternalError</td><td>内部错误。用于指示Java虚拟机发生了内部错误。</td></tr><tr><td>java.lang.LinkageError</td><td>链接错误。该错误及其所有子类指示某个类依赖于另外一些类，在该类编译之后，被依赖的类改变了其类定义而没有重新编译所有的类，进而引发错误的情况。</td></tr><tr><td>java.lang.NoClassDefFoundError</td><td>未找到类定义错误。当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。</td></tr><tr><td>java.lang.NoSuchFieldError</td><td>域不存在错误。当应用试图访问或者修改某类的某个域，而该类的定义中没有该域的定义时抛出该错误。</td></tr><tr><td>java.lang.NoSuchMethodError</td><td>方法不存在错误。当应用试图调用某类的某个方法，而该类的定义中没有该方法的定义时抛出该错误。</td></tr><tr><td>java.lang.OutOfMemoryError</td><td>内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</td></tr><tr><td>java.lang.StackOverflowError</td><td>堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误。</td></tr><tr><td>java.lang.ThreadDeath</td><td>线程结束。当调用Thread类的stop方法时抛出该错误，用于指示线程结束。</td></tr><tr><td>java.lang.UnknownError</td><td>未知错误。用于指示Java虚拟机发生了未知严重错误的情况。</td></tr><tr><td>java.lang.UnsatisfiedLinkError</td><td>未满足的链接错误。当Java虚拟机未找到某个类的声明为native方法的本机语言定义时抛出。</td></tr><tr><td>java.lang.UnsupportedClassVersionError</td><td>不支持的类版本错误。当Java虚拟机试图从读取某个类文件，但是发现该文件的主、次版本号不被当前Java虚拟机支持的时候，抛出该错误。</td></tr><tr><td>java.lang.VerifyError</td><td>验证错误。当验证器检测到某个类文件中存在内部不兼容或者安全问题时抛出该错误。</td></tr><tr><td>java.lang.VirtualMachineError</td><td>虚拟机错误。用于指示虚拟机被破坏或者继续执行操作所需的资源不足的情况。</td></tr><tr><td>java.lang.ArithmeticException</td><td>算术条件异常。譬如：整数除零等。</td></tr><tr><td>java.lang.ArrayIndexOutOfBoundsException</td><td>数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</td></tr><tr><td>java.lang.ArrayStoreException</td><td>数组存储异常。当向数组中存放非数组声明类型对象时抛出。</td></tr><tr><td>java.lang.ClassCastException</td><td>类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</td></tr><tr><td>java.lang.ClassNotFoundException</td><td>找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</td></tr><tr><td>java.lang.CloneNotSupportedException</td><td>不支持克隆异常。当没有实现Cloneable接口或者不支持克隆方法时,调用其clone()方法则抛出该异常。</td></tr><tr><td>java.lang.EnumConstantNotPresentException</td><td>枚举常量不存在异常。当应用试图通过名称和枚举类型访问一个枚举对象，但该枚举对象并不包含常量时，抛出该异常。</td></tr><tr><td>java.lang.Exception</td><td>根异常。用以描述应用程序希望捕获的情况。</td></tr><tr><td>java.lang.IllegalAccessException</td><td>违法的访问异常。当应用试图通过反射方式创建某个类的实例、访问该类属性、调用该类方法，而当时又无法访问类的、属性的、方法的或构造方法的定义时抛出该异常。</td></tr><tr><td>java.lang.IllegalMonitorStateException</td><td>违法的监控状态异常。当某个线程试图等待一个自己并不拥有的对象（O）的监控器或者通知其他线程等待该对象（O）的监控器时，抛出该异常。</td></tr><tr><td>java.lang.IllegalStateException</td><td>违法的状态异常。当在Java环境和应用尚未处于某个方法的合法调用状态，而调用了该方法时，抛出该异常。</td></tr><tr><td>java.lang.IllegalThreadStateException</td><td>违法的线程状态异常。当县城尚未处于某个方法的合法调用状态，而调用了该方法时，抛出异常。</td></tr><tr><td>java.lang.IndexOutOfBoundsException</td><td>索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</td></tr><tr><td>java.lang.InstantiationException</td><td>实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</td></tr><tr><td>java.lang.InterruptedException</td><td>被中止异常。当某个线程处于长时间的等待、休眠或其他暂停状态，而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常。</td></tr><tr><td>java.lang.NegativeArraySizeException</td><td>数组大小为负值异常。当使用负数大小值创建数组时抛出该异常。</td></tr><tr><td>java.lang.NoSuchFieldException</td><td>属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</td></tr><tr><td>java.lang.NoSuchMethodException</td><td>方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</td></tr><tr><td>java.lang.NullPointerException</td><td>空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</td></tr><tr><td>java.lang.NumberFormatException</td><td>数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</td></tr><tr><td>java.lang.RuntimeException</td><td>运行时异常。是所有Java虚拟机正常操作期间可以被抛出的异常的父类。</td></tr><tr><td>java.lang.SecurityException</td><td>安全异常。由安全管理器抛出，用于指示违反安全情况的异常。</td></tr><tr><td>java.lang.StringIndexOutOfBoundsException</td><td>字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</td></tr><tr><td>java.lang.TypeNotPresentException</td><td>类型不存在异常。当应用试图以某个类型名称的字符串表达方式访问该类型，但是根据给定的名称又找不到该类型是抛出该异常。该异常与ClassNotFoundException的区别在于该异常是unchecked（不被检查）异常，而ClassNotFoundException是checked（被检查）异常。</td></tr><tr><td>java.lang.UnsupportedOperationException</td><td>不支持的方法异常。指明请求的方法不被支持情况的异常。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql-DDL、DML、DCL、TCL定义</title>
    <link href="/2022/06/28/Mysql-DDL%E3%80%81DML%E3%80%81DCL%E3%80%81TCL%E5%AE%9A%E4%B9%89/"/>
    <url>/2022/06/28/Mysql-DDL%E3%80%81DML%E3%80%81DCL%E3%80%81TCL%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h3 id="1-DDL（Data-Definition-Language）数据库定义语言"><a href="#1-DDL（Data-Definition-Language）数据库定义语言" class="headerlink" title="1.DDL（Data Definition Language）数据库定义语言"></a>1.DDL（Data Definition Language）数据库定义语言</h3><blockquote><p>statements are used to define the database structure or schema.</p></blockquote><p>DDL是SQL语言的四大功能之一。用于定义数据库的三级结构，包括外模式、概念模式、内模式及其相互之间的映像，定义数据的完整性、安全控制等约束，DDL不需要commit.<br>CREATE<br>ALTER<br>DROP<br>TRUNCATE<br>COMMENT<br>RENAME</p><h3 id="2-DML（Data-Manipulation-Language）数据操纵语言"><a href="#2-DML（Data-Manipulation-Language）数据操纵语言" class="headerlink" title="2.DML（Data Manipulation Language）数据操纵语言"></a>2.DML（Data Manipulation Language）数据操纵语言</h3><blockquote><p>statements are used for managing data within schema objects.</p></blockquote><p>由DBMS提供，用于让用户或程序员使用，实现对数据库中数据的操作。DML分成交互型DML和嵌入型DML两类。<br>依据语言的级别，DML又可分成过程性DML和非过程性DML两种。需要commit。<br>SELECT<br>INSERT<br>UPDATE<br>DELETE<br>MERGE<br>CALL<br>EXPLAIN PLAN<br>LOCK TABLE</p><h3 id="3-DCL（Data-Control-Language）数据库控制语言-授权，角色控制等"><a href="#3-DCL（Data-Control-Language）数据库控制语言-授权，角色控制等" class="headerlink" title="3.DCL（Data Control Language）数据库控制语言  授权，角色控制等"></a>3.DCL（Data Control Language）数据库控制语言  授权，角色控制等</h3><p>GRANT 授权<br>REVOKE 取消授权</p><h3 id="4-TCL（Transaction-Control-Language）事务控制语言"><a href="#4-TCL（Transaction-Control-Language）事务控制语言" class="headerlink" title="4.TCL（Transaction Control Language）事务控制语言"></a>4.TCL（Transaction Control Language）事务控制语言</h3><p>SAVEPOINT 设置保存点<br>ROLLBACK  回滚<br>SET TRANSACTION</p><h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5.结论"></a>5.结论</h3><p>SQL主要分成四部分：</p><p>（1）数据定义。（SQL DDL）用于定义SQL模式、基本表、视图和索引的创建和撤消操作。<br>（2）数据操纵。（SQL DML）数据操纵分成数据查询和数据更新两类。数据更新又分成插入、删除、和修改三种操作。<br>（3）数据控制。包括对基本表和视图的授权，完整性规则的描述，事务控制等内容。<br>（4）嵌入式SQL的使用规定。涉及到SQL语句嵌入在宿主语言程序中使用的规则。</p>]]></content>
    
    
    <categories>
      
      <category>MYSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDL、DML、DCL、TCL定义</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础-读取系统属性</title>
    <link href="/2022/06/28/java%E5%9F%BA%E7%A1%80-%E8%AF%BB%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7/"/>
    <url>/2022/06/28/java%E5%9F%BA%E7%A1%80-%E8%AF%BB%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties props=System.getProperties(); <span class="hljs-comment">//系统属性</span><br>    System.out.println(<span class="hljs-string">&quot;Java的运行环境版本：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.version&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的运行环境供应商：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vendor&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java供应商的URL：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vendor.url&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的安装路径：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.home&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的虚拟机规范版本：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vm.specification.version&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的虚拟机规范供应商：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vm.specification.vendor&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的虚拟机规范名称：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vm.specification.name&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的虚拟机实现版本：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vm.version&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的虚拟机实现供应商：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vm.vendor&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的虚拟机实现名称：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vm.name&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java运行时环境规范版本：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.specification.version&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java运行时环境规范供应商：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.specification.vender&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java运行时环境规范名称：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.specification.name&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的类格式版本号：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.class.version&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的类路径：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;加载库时搜索的路径列表：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.library.path&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;默认的临时文件路径：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.io.tmpdir&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;一个或多个扩展目录的路径：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.ext.dirs&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;操作系统的名称：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;os.name&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;操作系统的构架：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;os.arch&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;操作系统的版本：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;os.version&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;文件分隔符：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;file.separator&quot;</span>));   <span class="hljs-comment">//在 unix 系统中是＂／＂</span><br>    System.out.println(<span class="hljs-string">&quot;路径分隔符：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;path.separator&quot;</span>));   <span class="hljs-comment">//在 unix 系统中是＂:＂</span><br>    System.out.println(<span class="hljs-string">&quot;行分隔符：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;line.separator&quot;</span>));   <span class="hljs-comment">//在 unix 系统中是＂/n＂</span><br>    System.out.println(<span class="hljs-string">&quot;用户的账户名称：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;user.name&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;用户的主目录：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;user.home&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;用户的当前工作目录：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读取系统属性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java并发编程-可重入锁、公平锁与非公平锁、读写锁</title>
    <link href="/2022/06/28/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <url>/2022/06/28/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h3 id="一、可重入锁"><a href="#一、可重入锁" class="headerlink" title="一、可重入锁"></a>一、可重入锁</h3><ol><li><p>定义<br>可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。 换一种说法：同一个线程再次进入同步代码时，可以使用自己已获取到的锁。 防止在同一线程中多次获取锁而导致死锁发生。</p></li><li><p>在ReentrantLock中的实现</p></li></ol><p><strong>获取锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-comment">//第一次拿到锁，设置state为acquire</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <br>                <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                    setExclusiveOwnerThread(current);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 该线程再次进入锁，设置state为state+acquire</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>                setState(nextc);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>如果对同步状态获取还有疑问的可以参考上一篇文章<a href="https://blog.csdn.net/qq_24863743/article/details/105891274">AQS同步器源码解析</a>，由以上代码我们可以看出当线第一次拿到锁的时候即if (c &#x3D;&#x3D; 0) 为true时，设置state&#x3D;acruire；当再次进入该代码块时，判断如果是同一个线程则对state做一个累加，返回true即认为获取锁成功。这里可能有疑问的是为什么要做累加而不是直接返回true?其实这个操作是为了之后的释放锁，这里累加操作的时候也相当于记录一个进入的次数，以便释放的时候直到何时释放完成。</p><p><strong>释放锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>            <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果state为0则认为释放完成</span><br>                free = <span class="hljs-literal">true</span>;<br>                setExclusiveOwnerThread(<span class="hljs-literal">null</span>); <span class="hljs-comment">//标识自己已不再持有锁</span><br>            &#125;<br>            setState(c); <span class="hljs-comment">// state如果不为0，认为还为释放完成，该线程还占有锁</span><br>            <span class="hljs-keyword">return</span> free;<br>        &#125;<br></code></pre></td></tr></table></figure><p>释放锁的时候，先判断同步状态是否为0，如果是则认为锁释放完成并把标识自己已不再持有该锁；如果否则认为还为释放完成，只是简单的设置状态。</p><h3 id="二、公平锁与非公平锁"><a href="#二、公平锁与非公平锁" class="headerlink" title="二、公平锁与非公平锁"></a>二、公平锁与非公平锁</h3><ol><li><p>定义<br>公平锁（Fair）：加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得<br>非公平锁（Nonfair）：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待<br>通常非公平锁的性能高于公平锁，公平锁需要等待线程唤醒，唤醒线程需要一定的开销；而非公平锁很有可能会在唤醒线程过程中拿到锁执行完任务并释放了锁；此时被唤醒的线程继续拿锁做其他的事，所以非公平锁的效率要高于公平锁。</p></li><li><p>ReentrantLock中公平锁和非公平锁的实现<br><strong>非公平锁</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                    setExclusiveOwnerThread(current);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>                setState(nextc);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p><strong>公平锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                    compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                    setExclusiveOwnerThread(current);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>                setState(nextc);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>对比公平锁和非公平锁的实现，我们会发现差别就在于公平锁（if(!hasQueuedPredecessors() &amp;&amp;compareAndSetState(0, acquires))）获取同步状态时先去判定等待队列是否有正在排队的线程，有则直接去队尾排队，无则使用CAS指令去修改同步状态。非公平锁（if (compareAndSetState(0, acquires))）直接就去修改同步状态，不管你队列中是否有排队的节点。</p><h3 id="三、读写锁（ReentrantReadWriteLock-的实现）"><a href="#三、读写锁（ReentrantReadWriteLock-的实现）" class="headerlink" title="三、读写锁（ReentrantReadWriteLock 的实现）"></a>三、读写锁（ReentrantReadWriteLock 的实现）</h3><blockquote><p>写独占，读共享，读写互斥</p></blockquote><p>这句话我觉得总结得很精辟，读写锁非常适合读多写少的场景，而互联网企业的多数业务都是这种场景。</p><ol><li><p>读写状态的设计<br>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的<br>同步状态。回想 ReentrantLock 中自定义同步器的实现，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高 16 位表示读，低 16 位表示写，读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态值为 S，写状态等于 S&amp;0x0000FFFF（将高 16 位全部抹去），读状态等于 S&gt;&gt;&gt;16（无符号补 0 右移 16 位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是S+0x00010000。根据状态的划分能得出一个推论：S 不等于 0 时，当写状态（S&amp;0x0000FFFF）等于 0 时，则读状态（S&gt;&gt;&gt;16）大于 0，即读锁已被获取。</p></li><li><p>写锁的获取与释放<br>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为 0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与 ReentrantLock 的释放过程基本类似，每次释放均减少写状态，当写状态为 0 时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。</p></li><li><p>读锁的获取与释放<br>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为 0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在 ThreadLocal 中，由线程自身维护。在 tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠 CAS 保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程-AQS同步器源码解析</title>
    <link href="/2022/06/27/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-AQS%E5%90%8C%E6%AD%A5%E5%99%A8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/06/27/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-AQS%E5%90%8C%E6%AD%A5%E5%99%A8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="一、CLH队列锁"><a href="#一、CLH队列锁" class="headerlink" title="一、CLH队列锁"></a>一、CLH队列锁</h3><p>学习AQS之前先来了解下CLH队列锁，即 Craig, Landin, and Hagersten (CLH) locks。顾名思义，该锁维护了一个队列，每个节点代表一个线程，结构图如下：<br><img src="https://img-blog.csdnimg.cn/20200502170437804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当一个线程想要获取锁，首先把自己包装成一个队列节点，该节点需要记录前驱节点和一个是否需要获取锁的标识blocked默认值为true的，然后在前驱节点的blocked属性上进行自旋，知道前驱节点释放锁blocked为false时，标识该线程可以拿到锁并停止自旋，该线程执行完业务逻辑后释放锁blocked变为false，下一个节点拿到锁重复相同步骤，直到队列为空。</p><p>AQS(AbstractQueuedSynchronizer)是java中CLH锁的一种变体实现，它是用来构建锁或者其他同步组件的基础框架，它使用了一个 int 成员变量表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的排队工作。常用的ReentrantLock和ReentrantReadWriteLock锁都是基于AQS来实现了。</p><h3 id="一、AQS使用的设计模式"><a href="#一、AQS使用的设计模式" class="headerlink" title="一、AQS使用的设计模式"></a>一、AQS使用的设计模式</h3><ol><li><strong>模板设计模式:</strong><br>什么是模板设计模式？定义了一个操作中的算法的骨架，而将部分步骤的实现在子类中完成。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br>AQS中获取同步状态的方法，例如acquire():</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>           selfInterrupt();<br>   &#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>   &#125;<br></code></pre></td></tr></table></figure><p>该方法在AQS中并没有实现，而是交给子类去实现，而AQS的主流程中又依赖这个方法，所以这是典型的模板设计方法。<br>在AQS中使用模板设计模式的有如下方法，在实现自己的同步器的时候需要重写对应的方法，这些模板方法基本上分为 3 类：独占式获取与释放同步状态、共享式获取与释放、同步状态和查询同步队列中的等待线程情况。<br><img src="https://img-blog.csdnimg.cn/20200502160342612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="二、独占式同步状态获取与释放"><a href="#二、独占式同步状态获取与释放" class="headerlink" title="二、独占式同步状态获取与释放"></a>二、独占式同步状态获取与释放</h3><h4 id="1、同步状态获取"><a href="#1、同步状态获取" class="headerlink" title="1、同步状态获取"></a>1、同步状态获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br></code></pre></td></tr></table></figure><p>首先调用tryAcquire方法而且是根据该方法的返回接过来确定是否接着往下走，因为是独占式的获取，所以拿锁的动作要么成功要么失败。如果返回true则认为线程成功获取同步状态，继续执行业务代码。如果获取失败则，调用acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br><strong>先来看下addWaiter()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>        <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>            node.prev = pred;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>                pred.next = node;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125;<br>        enq(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>                <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                    tail = head;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node.prev = t;<br>                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                    t.next = node;<br>                    <span class="hljs-keyword">return</span> t;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>该方法接收一个mode参数，该参数在AQS的内部类中有定义，一个是标识共享模式等待，一个是独占式。<br><img src="https://img-blog.csdnimg.cn/20200502171426380.png" alt="在这里插入图片描述"><br>该方法先将线程封装成一个节点，目的是将该节点设置为当前队列的尾节点，先尝试设置一次，如果成功就返回设置成功。如果失败就进入enq()方法开始无限循环，直到把自己设置为尾节点。<br><strong>接下来是acquireQueued</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    setHead(node);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">return</span> Thread.interrupted();<br>    &#125;<br></code></pre></td></tr></table></figure><p>先拿到该节点的前驱节点并判断是否是head节点，如果是则再次尝试获取同步状态成功则把自己置为头节点，并将头节点指向null使之能被gc回收，然后返回；失败则继续往下走。<br>parkAndCheckInterrupt（）该方法则是调用LockSupport的park的方法。这里先说一下LockSupport，LockSupport 定义了一组以 park 开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程，这些方法提供了最基本的线程阻塞和唤醒功能，而 LockSupport 也成为构建同步组件的基础工具。<br>所以如果线程没有获取到同步状态，这该线程会被放在FIFO队列里并且是一个阻塞状态。那么什么时候该线程能够被唤起呢？</p><h4 id="2、同步状态释放"><a href="#2、同步状态释放" class="headerlink" title="2、同步状态释放"></a>2、同步状态释放</h4><p>当线程的业务代码执行完，需要释放同步状态，独占式的释放调用的是release方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>                unparkSuccessor(h);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>        <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>            compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>            s = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>                <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                    s = t;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>            LockSupport.unpark(s.thread);<br>    &#125;<br></code></pre></td></tr></table></figure><p>首先调用tryRelease（）释放锁，失败则返回，成功则释放它的下一个被阻塞的节点。<img src="https://img-blog.csdnimg.cn/20200502184609765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这段代码可能有人会看的比较晕，其实是它先拿到下一个节点，先判断节点的状态。AQS类有个Node内部类，这里定义了Node的四种状态：</p><blockquote><p>CANCELLED：值为 1，表示线程的获锁请求已经“取消” SIGNAL：值为-1，表示该线程一切都准备好了,就等待锁空闲出来给我<br>CONDITION：值为-2，表示线程等待某一个条件（Condition）被满足<br>PROPAGATE：值为-3，当线程处在“SHARED”模式时，该字段才会被使用 上 初始化 Node 对象时，默认为 0</p></blockquote><p>所以当节点的状态大于0时只有删除状态，而唤醒的节点不应该是已经删除的，而for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)明显看出，下一个节点是从队列的尾开始遍历而不是拿删除节点的下一个节点，至于为什么？ 猜测可能的原因是导致节点删除的原因主要是超时，而既然先请求的节点都删除了，那么删除节点的下一个节点也大概率是删除的，所以从尾部遍历。找到未删除的节点，然后调用unPark唤醒。</p><h3 id="三、共享式的同步状态获取与释放"><a href="#三、共享式的同步状态获取与释放" class="headerlink" title="三、共享式的同步状态获取与释放"></a>三、共享式的同步状态获取与释放</h3><h4 id="1、同步状态获取-1"><a href="#1、同步状态获取-1" class="headerlink" title="1、同步状态获取"></a>1、同步状态获取</h4><p>我们先看下共享式的释放代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>            doAcquireShared(arg);<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                        setHeadAndPropagate(node, r);<br>                        p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                        <span class="hljs-keyword">if</span> (interrupted)<br>                            selfInterrupt();<br>                        failed = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>tryAcquireShared(arg) &lt; 0，判断是否获取成功不再是Boolean值，这是因为共享式的获取可能有多个线程同时获取到同步状态。可以认为tryAcquireShared返回大于0的值时成功拿到，而同步状态被拿完了则进入等待队列。进入等待队列时，判断前一个节点是否是head节点，如果是则再尝试获取一次锁，如果没有获取到则调用parkAndCheckInterrupt进入阻塞状态，等待被唤起。<br>此时要是成功拿到了，它会认为还有空闲的可以拿，则会调用setHeadAndPropagate唤起它后面的节点去获取同步状态，如果获取成功接着传播，失败则再次进入阻塞状态等待唤起。</p><h4 id="2-共享式的释放"><a href="#2-共享式的释放" class="headerlink" title="2.  共享式的释放"></a>2.  共享式的释放</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>            doReleaseShared();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                        <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                    unparkSuccessor(h);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                         !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>首先调用tryReleaseShared（）检查是否可以释放，false则直接返回释放失败，true则会唤醒下一个节点。由于时共享式的释放，所以可能你还没有唤醒下一节点，已经被其他线程唤醒，这时候会再循环一次直到唤醒下一个节点或者没有可被唤醒的节点退出。</p><h3 id="四、超时获取与释放"><a href="#四、超时获取与释放" class="headerlink" title="四、超时获取与释放"></a>四、超时获取与释放</h3><p>无论是独占式还是共享式的超时同步状态与获取其实都是一样的，调用LockSupport.park式传入一个超时时间，超过时间未被唤醒则中断返回；如果未超时被唤醒则重新获取，未获取到重新计算超时时间继续阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>            <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor(); <span class="hljs-comment">//获取前驱节点</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    setHead(node);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                nanosTimeout = deadline - System.nanoTime();  <span class="hljs-comment">//重新计算</span><br>                <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    nanosTimeout &gt; spinForTimeoutThreshold)<br>                    LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout); <span class="hljs-comment">//超时时间</span><br>                <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="五、实现独占式锁"><a href="#五、实现独占式锁" class="headerlink" title="五、实现独占式锁"></a>五、实现独占式锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyExclusiveLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-comment">// 静态内部类，自定义同步器</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, arg)) &#123;<br>                setExclusiveOwnerThread(thread);  <span class="hljs-comment">//表示当前线程拿到了锁</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    Sync sync=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; ready get lock&quot;</span>);<br>        sync.acquire(<span class="hljs-number">1</span>);<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;  allready got lock&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; release lock&quot;</span>);<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMyLock</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">long</span> start=System.currentTimeMillis();<br>        <span class="hljs-type">MyExclusiveLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyExclusiveLock</span>();<br>        Thread[] threads=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[<span class="hljs-number">5</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                lock.lock();<br>                ms(<span class="hljs-number">2000</span>);<br>                lock.unlock();<br>            &#125;);<br>            threads[i]=thread;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>            thread.start();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                thread.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;耗时: &quot;</span>+(System.currentTimeMillis()-start)+<span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br>&#125;<br>输出：<br>Thread-<span class="hljs-number">0</span> ready get lock<br>Thread-<span class="hljs-number">2</span> ready get lock<br>Thread-<span class="hljs-number">2</span>  allready got lock<br>Thread-<span class="hljs-number">1</span> ready get lock<br>Thread-<span class="hljs-number">3</span> ready get lock<br>Thread-<span class="hljs-number">4</span> ready get lock<br>Thread-<span class="hljs-number">2</span> release lock<br>Thread-<span class="hljs-number">1</span>  allready got lock<br>Thread-<span class="hljs-number">1</span> release lock<br>Thread-<span class="hljs-number">0</span>  allready got lock<br>Thread-<span class="hljs-number">0</span> release lock<br>Thread-<span class="hljs-number">3</span>  allready got lock<br>Thread-<span class="hljs-number">3</span> release lock<br>Thread-<span class="hljs-number">4</span>  allready got lock<br>Thread-<span class="hljs-number">4</span> release lock<br>耗时: 10300ms<br></code></pre></td></tr></table></figure><h3 id="六、实现共享式锁"><a href="#六、实现共享式锁" class="headerlink" title="六、实现共享式锁"></a>六、实现共享式锁</h3><p>共享锁代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySharedLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count; <span class="hljs-comment">//定义可同时获取锁的线程数</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sync</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>            <span class="hljs-built_in">this</span>.count = count;<br>            setState(count);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-keyword">for</span> (; ; ) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">newState</span> <span class="hljs-operator">=</span> state - arg;<br>                <span class="hljs-keyword">if</span> (newState &lt; <span class="hljs-number">0</span> || compareAndSetState(state, newState)) &#123;<br>                    <span class="hljs-keyword">return</span> newState;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-keyword">for</span> (; ; ) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">newState</span> <span class="hljs-operator">=</span> state + arg;<br>                <span class="hljs-keyword">if</span> (newState &gt; count) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> compareAndSetState(state, newState);<br>                &#125;<br><br>            &#125;<br>        &#125;<br><br>    &#125;<br><br><br>    Sync sync=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">//同时支持3个线程获取到锁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;ready get lock&quot;</span>);<br>        sync.acquireShared(<span class="hljs-number">1</span>);<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;allready got lock&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;release lock&quot;</span>);<br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMySharedLock</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">long</span> start=System.currentTimeMillis();<br>        <span class="hljs-type">MySharedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySharedLock</span>();<br>        Thread[] threads=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[<span class="hljs-number">9</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                lock.lock();<br>                ms(<span class="hljs-number">2000</span>);<br>                lock.unlock();<br>            &#125;);<br>            threads[i]=thread;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>            thread.start();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                thread.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;耗时: &quot;</span>+(System.currentTimeMillis()-start)+<span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br><br>&#125;<br><br>输出：<br>Thread-0ready get lock<br>Thread-0allready got lock<br>Thread-1ready get lock<br>Thread-1allready got lock<br>Thread-2ready get lock<br>Thread-2allready got lock<br>Thread-3ready get lock<br>Thread-4ready get lock<br>Thread-5ready get lock<br>Thread-7ready get lock<br>Thread-6ready get lock<br>Thread-8ready get lock<br>Thread-1release lock<br>Thread-3allready got lock<br>Thread-2release lock<br>Thread-4allready got lock<br>Thread-0release lock<br>Thread-5allready got lock<br>Thread-3release lock<br>Thread-7allready got lock<br>Thread-4release lock<br>Thread-6allready got lock<br>Thread-5release lock<br>Thread-8allready got lock<br>Thread-7release lock<br>Thread-6release lock<br>Thread-8release lock<br>耗时: 6091ms<br></code></pre></td></tr></table></figure><p>共9个线程每个线程休眠2秒钟，我们的锁定义的可同时支持3个线程拿到锁，所以耗时6091ms可证明每次确实有三个线程获取到锁。</p><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用 tryRelease(int arg)方法释放同步状态，然后唤醒 head 指向节点的后继节点</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>terminal配置git</title>
    <link href="/2022/06/27/terminal%E9%85%8D%E7%BD%AEgit/"/>
    <url>/2022/06/27/terminal%E9%85%8D%E7%BD%AEgit/</url>
    
    <content type="html"><![CDATA[<p>老话说在前头：工欲善其事，必先利其器。想要玩转 macOS 的终端，想要用的顺手、看着高端，折腾是必不可少的。</p><h3 id="第一步，安装-HomeBrew"><a href="#第一步，安装-HomeBrew" class="headerlink" title="第一步，安装 HomeBrew"></a><strong>第一步，安装 <a href="https://brew.sh/index_zh-cn.html">HomeBrew</a></strong></h3><p>作为 macOS 必备的包管理工具，相信大家肯定已经很熟悉了，没安装的朋友可以执行下面命令装一下，安装过的可以执行下面命令可以进行更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/bin/ruby -e <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL &lt;https://raw.githubusercontent.com/Homebrew/install/master/install&gt;)</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="第二步，更新-zsh、git"><a href="#第二步，更新-zsh、git" class="headerlink" title="第二步，更新 zsh、git"></a><strong>第二步，更新 zsh、git</strong></h3><p>macOS 一般会自带 zsh，不过版本会比较早，我们先更新一下，以便使用最新特性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install zsh<br><br>==&gt; Downloading &lt;https://homebrew.bintray.com/bottles/zsh-5.7.1.high_sierra.bottle.tar.gz&gt;<br><span class="hljs-comment">######################################################################## 100.0%</span><br>==&gt; Pouring zsh-5.7.1.high_sierra.bottle.tar.gz<br>/usr/local/Cellar/zsh/5.7.1: 1,515 files, 13.3MB<br></code></pre></td></tr></table></figure><h3 id="第三步，切换至-zsh-并安装-oh-my-zsh"><a href="#第三步，切换至-zsh-并安装-oh-my-zsh" class="headerlink" title="第三步，切换至 zsh 并安装 oh-my-zsh"></a><strong>第三步，切换至 zsh 并安装 oh-my-zsh</strong></h3><p>查看当前使用的 shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span><br><br>/bin/bash<br></code></pre></td></tr></table></figure><p>查看安装的 shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/shells<br><br>/bin/bash<br>/bin/csh<br>/bin/ksh<br>/bin/sh<br>/bin/tcsh<br>/bin/zsh<br></code></pre></td></tr></table></figure><p>切换为 zsh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chsh -s /bin/zsh<br></code></pre></td></tr></table></figure><p>重启终端即可使用 zsh。</p><p>接下来安装 oh-my-zsh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL &lt;https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh&gt;)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>安装完成后，终端展示如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">  ____  / /_     ____ ___  __  __   ____  _____/ /_<br> / __ \\/ __ \\   / __ `__ \\/ / / /  /_  / / ___/ __ \\<br>/ /_/ / / / /  / / / / / / /_/ /    / /_(__  ) / / /<br>\\____/_/ /_/  /_/ /_/ /_/\\__, /    /___/____/_/ /_/<br>                        /____/                       ....is now installed!<br><br>Please look over the ~/.zshrc file to select plugins, themes, and options.<br><br>p.s. Follow us at &lt;https://twitter.com/ohmyzsh&gt;.<br><br>p.p.s. Get stickers and t-shirts at &lt;http://shop.planetargon.com&gt;.<br></code></pre></td></tr></table></figure><h3 id="第四步，配置-oh-my-zsh"><a href="#第四步，配置-oh-my-zsh" class="headerlink" title="第四步，配置 oh-my-zsh"></a><strong>第四步，配置 oh-my-zsh</strong></h3><p>看到这里，安装流程已经完毕啦，执行最后的配置，就可以进行体验了。</p><p>打开 oh-my-zsh 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打开 zshrc 文件进行编辑，也可以使用 vim 编辑器</span><br>open ~/.zshrc<br><span class="hljs-comment"># 本人使用的是 vs code</span><br>open ~/.zshrc -a Visual\\ Studio\\ Code<br></code></pre></td></tr></table></figure><p><strong>主题</strong></p><p>配置项 <code>ZSH_THEME</code> 即为 oh-my-zsh 的主题配置，oh-my-zsh 的 GitHub Wiki 页面提供了 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes">主题列表</a>当设置为 <code>ZSH_THEME=random</code> 时，每次打开终端都会使用一种随机的主题。</p><p><strong>插件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">plugins=(git osx autojump zsh-autosuggestions zsh-syntax-highlighting)<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>其中 zsh-autosuggestions 和 zsh-syntax-highlighting 是自定义安装的插件，需要用 git 将插件 clone 到指定插件目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 自动提示插件</span><br>git <span class="hljs-built_in">clone</span> &lt;https://github.com/zsh-users/zsh-autosuggestions.git&gt; <span class="hljs-variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions<br><span class="hljs-comment"># 语法高亮插件</span><br>git <span class="hljs-built_in">clone</span> &lt;https://github.com/zsh-users/zsh-syntax-highlighting.git&gt; <span class="hljs-variable">$ZSH_CUSTOM</span>/plugins/zsh-syntax-highlighting<br></code></pre></td></tr></table></figure><p>需要其他插件的可以自行安装，如果插件未安装，开启终端的时候会报错，按照错误提示，安装对应的插件即可。</p><p>更新配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><p>更新完配置即可生效，不想更新配置的话，新开一个终端同样可以生效。</p><p>正所谓风雨之后见彩虹，经过这一番捣鼓，电脑用起来更加顺手了，可以愉快的开发了。</p>]]></content>
    
    
    <categories>
      
      <category>机器配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zsh、git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java并发编程-wait、notify、notifyAll</title>
    <link href="/2022/06/26/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-wait%E3%80%81notify%E3%80%81notifyAll/"/>
    <url>/2022/06/26/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-wait%E3%80%81notify%E3%80%81notifyAll/</url>
    
    <content type="html"><![CDATA[<p><strong>首先说以下这个几个方法归属，这几个方法并不是Thread类的方法，而是Object的方法，只是在多线程编程中实现线程间同步用到而已。</strong></p><h3 id="一、方法的作用"><a href="#一、方法的作用" class="headerlink" title="一、方法的作用"></a>一、方法的作用</h3><h4 id="1-wait-方法"><a href="#1-wait-方法" class="headerlink" title="1.wait()方法"></a>1.wait()方法</h4><p>如果某个线程调用的对象的wait()方法，那么该线程会进入到该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p><h4 id="2-notify-x2F-notifyAll方法"><a href="#2-notify-x2F-notifyAll方法" class="headerlink" title="2.notify&#x2F;notifyAll方法"></a>2.notify&#x2F;notifyAll方法</h4><p>当某个线程调用了对象的notify方法，那么会在该对象的等待池中唤醒一个线程进入到锁池中，锁池中的线程是可以参与竞争对象的锁的。notifyAll方法则是唤醒所有等待池中的方法进入到等待池中。当该线程执行完run方法后释放对象的锁，则所有锁池中的线程开始竞争锁，其他未竞争到锁的线程仍旧会在锁池中等待下一次锁释放。</p><h3 id="二、wait-notify编程的标准范式"><a href="#二、wait-notify编程的标准范式" class="headerlink" title="二、wait\notify编程的标准范式"></a>二、wait\notify编程的标准范式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Object o=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">synchronized</span>(o)&#123;<br><span class="hljs-keyword">while</span>(condition 不满足条件)&#123;<br>o.wait();<br>&#125;<br><span class="hljs-keyword">do</span> sth;<br>&#125;<br><br><span class="hljs-keyword">synchronized</span>(o)&#123;<br>change condition;<br>o.notify()/o.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、面试题"><a href="#三、面试题" class="headerlink" title="三、面试题"></a>三、面试题</h3><p><strong>问题：让两个线程交替打印0-100</strong></p><p>首先我们定义一个打印机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderPrint</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> number;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Oushu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-keyword">while</span> (number &lt; <span class="hljs-number">101</span> &amp;&amp; thread.isInterrupted() == <span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">if</span> (number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(thread.getName() + <span class="hljs-string">&quot;print: &quot;</span> + number);<br>                number++;<br>                SleepTools.ms(<span class="hljs-number">100</span>);<br>                notify();<br>                <span class="hljs-keyword">if</span> (number == <span class="hljs-number">101</span>) &#123; <span class="hljs-comment">// 判断是否已打印最后一个数字，如果是则通知线程你该关闭了</span><br>                    thread.interrupt();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">//                    e.printStackTrace();</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;偶数打印完毕, &quot;</span>+thread.getName()+<span class="hljs-string">&quot;==结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Jishu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-keyword">while</span> (number &lt; <span class="hljs-number">101</span> &amp;&amp; thread.isInterrupted() == <span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">if</span> (number % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                System.out.println(thread.getName() + <span class="hljs-string">&quot;print: &quot;</span> + number);<br>                number++;<br>                SleepTools.ms(<span class="hljs-number">100</span>);<br>                notify();<br>                <span class="hljs-keyword">if</span> (number == <span class="hljs-number">99</span>) &#123;   <span class="hljs-comment">// 判断是否已打印最后一个数字，如果是则通知线程你该关闭了</span><br>                    thread.interrupt();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;奇数打印完毕, &quot;</span> + thread.getName() + <span class="hljs-string">&quot;==结束&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再定义两个线程，分别打印奇数和偶数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderPrintTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> OrderPrint orderPrint=<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderPrint</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OushuRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            orderPrint.Oushu();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">500</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JishuRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            orderPrint.Jishu();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">500</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JishuRunnable</span>()).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OushuRunnable</span>()).start();<br>    &#125;<br>&#125;<br><br>输出：<br>。。。<br>Thread-1print: <span class="hljs-number">94</span><br>Thread-0print: <span class="hljs-number">95</span><br>Thread-1print: <span class="hljs-number">96</span><br>Thread-0print: <span class="hljs-number">97</span><br>Thread-1print: <span class="hljs-number">98</span><br>Thread-0print: <span class="hljs-number">99</span><br>Thread-1print: <span class="hljs-number">100</span><br>偶数打印完毕, Thread-<span class="hljs-number">1</span>==结束<br>奇数打印完毕, Thread-<span class="hljs-number">0</span>==结束<br></code></pre></td></tr></table></figure><p><strong>代码分析</strong>：<br>启动两个线程一起竞争打印机的锁，其中一个线程获取到锁后执行打印前先判断当前数字是否是我的业务范围，如果是：打印这个数字，判断是不是我需要打印的最后一个数字，接着进入wait()状态。</p><ol><li>为社么要判断是不是最后一个数字？<br>假设没有这个判断，奇数打印完99之后number&#x3D;100，然后进入wait状态；偶数打印完100之后number&#x3D;101，通知奇数线程启动，奇数判断不符合条件结束线程。此时偶数线程还处在wait状态，导致线程不能被唤醒，一直处于wait状态。这里关于interrupt的用法可以参考之前的文章。</li><li>线程执行notify之后可能还会拿到锁吗？<br>亲身实验过了，以为调用notify之后并没有执行对象的wait方法，该方法执行完任务之后还是会进入到锁池和被唤醒的线程一起去争夺锁。即使再拿到锁，不符合要求会调用对象的wait方法，使线程再进入到wait状态。</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java并发编程-synchronized、volatile和threadlocal</title>
    <link href="/2022/06/26/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-synchronized%E3%80%81volatile%E5%92%8CThread-Local/"/>
    <url>/2022/06/26/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-synchronized%E3%80%81volatile%E5%92%8CThread-Local/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Synchroinzed锁"><a href="#一、Synchroinzed锁" class="headerlink" title="一、Synchroinzed锁"></a>一、<strong>Synchroinzed锁</strong></h3><p>synchroinzed锁又称为内置锁，之前提到过进程中的线程是共享进程内所有资源的，当多个线程对同一个资源执行操作时，如果不加锁可能会导致最终结果和预期结果不符，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>            i++;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        SynchronizedTest synchronizedTest;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SynTest</span><span class="hljs-params">(SynchronizedTest synchronizedTest)</span> &#123;<br>            <span class="hljs-built_in">this</span>.synchronizedTest = synchronizedTest;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10000</span> ; i++) &#123;<br>                synchronizedTest.add();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SynchronizedTest</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br>        <span class="hljs-comment">// 线程一</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynTest</span>(s)).start();<br>        <span class="hljs-comment">//线程二</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynTest</span>(s)).start();<br>        SleepTools.second(<span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;结果：&quot;</span>+s.i);<br>    &#125;<br>&#125;<br>输出：<br>结果：<span class="hljs-number">18876</span><br></code></pre></td></tr></table></figure><p>输出的结果和预期的20000并不一样，这是因为两个线程同时对该值进行操作，每个线程执行加一操作时需要做两个步骤，首先获取到i的值，然后加一再写到内存；当线程一刚取到值但是还没写，线程二也取值，两个线程都完成加一回写时，实际上这两个线程写的是同一个值。<br>这时候就需要加锁，关键字synchronized 可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p><ol><li>修饰方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>            i++;<br>    &#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>修饰代码块</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">//this指当前实例对象</span><br>            i++;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>修饰成员变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object o=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">synchronized</span> (o) &#123;<br>           i++;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>这个和修饰代码块里的this道理是一样的，都是锁的某个对象。</p><ol start="4"><li>修饰静态方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>            i++;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当synchronized修饰静态方法或静态成员变量时有人说是类锁，实际上锁的虚拟机中该类所对应的class对象，本质上还是类锁。</p><ol start="5"><li><p>面试题<br><strong>对象锁和类锁可以并行运行吗？</strong><br>面试经常回问到这个问题，就如上面所说的，类锁锁的是xxx.class对象，对象锁锁的是‘对象xxx’，锁的不是同一个对象肯定是可以并行的。</p></li><li><p><strong>synchroized错误使用</strong>，如下代码：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadStart</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> Integer i;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable</span><span class="hljs-params">(Integer i)</span> &#123;<br>            <span class="hljs-built_in">this</span>.i = i;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (i) &#123;<br>                Thread thread=Thread.currentThread();<br>                System.out.println(thread.getName()+<span class="hljs-string">&quot;==开始==&quot;</span>+i+<span class="hljs-string">&quot;@&quot;</span>+System.identityHashCode(i));<br>                i++;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(thread.getName()+<span class="hljs-string">&quot;==结束==&quot;</span>+i+<span class="hljs-string">&quot;@&quot;</span>+System.identityHashCode(i)); <span class="hljs-comment">//identityHashCode方法可以理解为内存中的地址</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyRunnable a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">5</span> ; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(a).start();<br>        &#125;<br>    &#125;<br>&#125;<br>输出结果：<br>Thread-<span class="hljs-number">0</span>==开始==<span class="hljs-number">1</span>@<span class="hljs-number">351452368</span><br>Thread-<span class="hljs-number">1</span>==开始==<span class="hljs-number">2</span>@<span class="hljs-number">733316467</span><br>Thread-<span class="hljs-number">2</span>==开始==<span class="hljs-number">3</span>@<span class="hljs-number">696436475</span><br>Thread-<span class="hljs-number">3</span>==开始==<span class="hljs-number">4</span>@<span class="hljs-number">2019092735</span><br>Thread-<span class="hljs-number">1</span>==结束==<span class="hljs-number">5</span>@<span class="hljs-number">628256373</span><br>Thread-<span class="hljs-number">0</span>==结束==<span class="hljs-number">5</span>@<span class="hljs-number">628256373</span><br>Thread-<span class="hljs-number">3</span>==结束==<span class="hljs-number">5</span>@<span class="hljs-number">628256373</span><br>Thread-<span class="hljs-number">4</span>==开始==<span class="hljs-number">5</span>@<span class="hljs-number">628256373</span><br>Thread-<span class="hljs-number">2</span>==结束==<span class="hljs-number">6</span>@<span class="hljs-number">658845115</span><br>Thread-<span class="hljs-number">4</span>==结束==<span class="hljs-number">6</span>@<span class="hljs-number">658845115</span><br></code></pre></td></tr></table></figure><p>按照预期，每个线程都对i进行加一，但实际结果thread-0起始值为1结束值为5，且地址也由351452368变为了628256373。从代码看明显是锁到了i且是同一个对象，为什么会出现这个异常？难道是没锁住？<br>我们把这个类反编译一下，结果如下：<br><img src="https://img-blog.csdnimg.cn/20200423214359565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从反编译的结果我们可以看到，当执行i++的时候实际返回的结果是Integer.valueOf(this.i.intValue() + 1);我们再去Integer类看看这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>    &#125;<br></code></pre></td></tr></table></figure><p>返回的是new Integer对象，那上边的问题就能够讲的通了，当每个线程执行++操作时，i实际都指向了另一个对象，synchroinzed关键字锁的是对象，这里强调的是同一个对象，这段代码当有一个线程返回时这个锁的对象就会发生变化，所有就出现了如上的输出。</p><p><strong>那么这个锁应该怎么加呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadStart</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> Integer i;<br><br>        <span class="hljs-keyword">private</span> Object o=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable</span><span class="hljs-params">(Integer i)</span> &#123;<br>            <span class="hljs-built_in">this</span>.i = i;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (o) &#123;<br>                Thread thread=Thread.currentThread();<br>                System.out.println(thread.getName()+<span class="hljs-string">&quot;==开始==&quot;</span>+i+<span class="hljs-string">&quot;@&quot;</span>+System.identityHashCode(i));<br>                i++;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(thread.getName()+<span class="hljs-string">&quot;==结束==&quot;</span>+i+<span class="hljs-string">&quot;@&quot;</span>+System.identityHashCode(i)); <span class="hljs-comment">//identityHashCode方法可以理解为内存中的地址</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyRunnable a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">5</span> ; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(a).start();<br>        &#125;<br>    &#125;<br>&#125;<br>输出：<br>Thread-<span class="hljs-number">0</span>==开始==<span class="hljs-number">1</span>@<span class="hljs-number">351452368</span><br>Thread-<span class="hljs-number">0</span>==结束==<span class="hljs-number">2</span>@<span class="hljs-number">439697470</span><br>Thread-<span class="hljs-number">4</span>==开始==<span class="hljs-number">2</span>@<span class="hljs-number">439697470</span><br>Thread-<span class="hljs-number">4</span>==结束==<span class="hljs-number">3</span>@<span class="hljs-number">1488227252</span><br>Thread-<span class="hljs-number">3</span>==开始==<span class="hljs-number">3</span>@<span class="hljs-number">1488227252</span><br>Thread-<span class="hljs-number">3</span>==结束==<span class="hljs-number">4</span>@<span class="hljs-number">2019092735</span><br>Thread-<span class="hljs-number">2</span>==开始==<span class="hljs-number">4</span>@<span class="hljs-number">2019092735</span><br>Thread-<span class="hljs-number">2</span>==结束==<span class="hljs-number">5</span>@<span class="hljs-number">696436475</span><br>Thread-<span class="hljs-number">1</span>==开始==<span class="hljs-number">5</span>@<span class="hljs-number">696436475</span><br>Thread-<span class="hljs-number">1</span>==结束==<span class="hljs-number">6</span>@<span class="hljs-number">733316467</span><br></code></pre></td></tr></table></figure><p>我们锁一个不会变化的对象就可以了，检查结果也是符合预期的。</p><h3 id="二、volatile"><a href="#二、volatile" class="headerlink" title="二、volatile"></a>二、volatile</h3><p>volatile是最轻量级的同步机制，一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义</p><ol><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。</li></ol><p>第一条比较好理解，主要是理解第二条，指令重排序的定义如下：</p><blockquote><p>为了尽可能减少内存操作速度远慢于CPU运行速度所带来的CPU空置的影响，虚拟机会按照自己的一些规则将程序编写顺序打乱——即写在后面的代码在时间顺序上可能会先执行，而写在前面的代码会后执行——以尽可能充分地利用CPU，但最终的执行结果不变。</p></blockquote><p>volatile只是保证可见性，即只是保证读一直性并不保证写只能有一个线程写，如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">VolatileTest</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-built_in">this</span>.i = i;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        VolatileTest volatileTest;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable</span><span class="hljs-params">(VolatileTest volatileTest)</span> &#123;<br>            <span class="hljs-built_in">this</span>.volatileTest = volatileTest;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10000</span> ; i++) &#123;<br>                volatileTest.add();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        VolatileTest v=<span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileTest</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(v)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(v)).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;i=&quot;</span>+v.i);<br>    &#125;<br>&#125;<br>输出：<br>i=<span class="hljs-number">19695</span><br></code></pre></td></tr></table></figure><p>所以，volatile关键字适合一写多读的场景。</p><h3 id="三、ThreadLocal"><a href="#三、ThreadLocal" class="headerlink" title="三、ThreadLocal"></a>三、ThreadLocal</h3><p>ThreadLocal类的作用是在多线程编程下，保证线程间数据的隔离，实现的方法就是为每个线程维护一个变量的副本。<br><strong>1. ThreadLocal使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Integer&gt; age=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Integer&gt;()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;;<br><br><span class="hljs-comment">//    private static int age=1;</span><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>            <span class="hljs-built_in">this</span>.number = number;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            Thread thread=Thread.currentThread();<br>            System.out.println(thread.getName()+<span class="hljs-string">&quot;==start==&quot;</span>+age.get());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><span class="hljs-comment">//            number=age.get()+number;</span><br>            age.set(number+age.get());<br><br>            System.out.println(thread.getName()+<span class="hljs-string">&quot;==end==&quot;</span>+age.get());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ThreadLocalTest threadLocalTest=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalTest</span>();<br><br>        Thread[] threads=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">3</span> ; i++) &#123;<br>            threads[i]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(i));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>            thread.start();<br>        &#125;<br>    &#125;<br>&#125;<br>输出：<br>Thread-<span class="hljs-number">0</span>==start==<span class="hljs-number">1</span><br>Thread-<span class="hljs-number">2</span>==start==<span class="hljs-number">1</span><br>Thread-<span class="hljs-number">1</span>==start==<span class="hljs-number">1</span><br>Thread-<span class="hljs-number">1</span>==end==<span class="hljs-number">2</span><br>Thread-<span class="hljs-number">0</span>==end==<span class="hljs-number">1</span><br>Thread-<span class="hljs-number">2</span>==end==<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>2. ThreadLocal的实现解析</strong><br><img src="https://img-blog.csdnimg.cn/20200424144134690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>声明一个ThreadLocal类型的属性，每个线程都会维护自己的一个ThreadLocalMap属性，查看Thread原密会发现这个属性<img src="https://img-blog.csdnimg.cn/20200424144340140.png" alt="在这里插入图片描述"><br>可看到该属性是专门为ThreadLocal设计的，而ThreadLocalMap又是ThreadLocal的内部类，查看ThreadLocal源码：<img src="https://img-blog.csdnimg.cn/2020042414455461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到有个 Entry 内部静态类，它继承了 WeakReference，总之它记录了两个信息，一个是 ThreadLocal&lt;?&gt;类型，一个是 Object 类型的值。getEntry 方法则是获取某个 ThreadLocal 对应的值，set 方法就是更新或赋值相应的 ThreadLocal<br>对应的值。<br>ThreadLocal的值获取流程就是，先获取当前线程的ThreadLocalMap属性，然后根据当前ThreadLocal的实例获取map中的Entry对象，即获取了值。</p><p><strong>3. ThreadLocal使用不当可能造成内存溢出</strong><br>先看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalOOMl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TASK_MAX_LOOP=<span class="hljs-number">500</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadPoolExecutor threadPoolExecutor=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<br>            TimeUnit.MINUTES,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;());<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariable</span>(); <span class="hljs-comment">//执行创建数组</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalVariable</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">5</span>]; <span class="hljs-comment">//创建一个5M的数组</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;TASK_MAX_LOOP ; i++) &#123;<br>            threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalOOMl</span>());<br>            System.out.println(<span class="hljs-string">&quot;not use threadLocal!&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;thread excute over!&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用jdk自带的jvm监控工具（位置在bin&#x2F;jvisualvm.exe），查看堆的使用大小如下：<br><img src="https://img-blog.csdnimg.cn/20200424185246548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们线程池的大小是5，也就是最多5个线程同时运行，占用的堆内存基本维持在25M以下这是正常的。有人可能会问每个线程new一个5M的数组为什么只有25M？看下代码new ThreadLocalOOMl()，我们每次只是在堆上new了一个对象，该对象并没有被引用，所以该对象会被回收，所以堆的内存大概只有25M。</p><p>使用ThreadLocal代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalOOMl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TASK_MAX_LOOP=<span class="hljs-number">500</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadPoolExecutor threadPoolExecutor=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<br>            TimeUnit.MINUTES,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;());<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;LocalVariable&gt; localVariable=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        localVariable.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariable</span>()); <span class="hljs-comment">//每个线程维护一个threadLocal副本</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalVariable</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">5</span>]; <span class="hljs-comment">//创建一个5M的数组</span><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;TASK_MAX_LOOP ; i++) &#123;<br>            threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalOOMl</span>());<br>            System.out.println(<span class="hljs-string">&quot;use threadLocal!&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;thread excute over!&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200424190850316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们的预期结果应该是和不使用threadLocal一致大概25M左右，实际上最高已经来到250左右，出现了内存溢出。这是为什么呢？接下来分析</p><p>分析之前先说以下java里的几种引用：</p><ol><li>强引用<br>就是指在程序代码之中普遍存在的，类似“Object obj&#x3D;new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象实例。</li><li>软引用<br>用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象实例列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK1.2 之后，提供了 SoftReference 类来实现软引用。</li><li>弱引用<br>用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象实例只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象实例。在 JDK 1.2 之后，提供了WeakReference 类来实现弱引用。</li><li>虚引用也称为幽灵引用或者幻影引用<br>它是最弱的一种引用关系。一个对象实例是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象实例被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了PhantomReference 类来实现虚引用。</li></ol><p>再来梳理以下ThreadLocal这个类，每个线程维护了一个ThreadLocalMap对象，它的key是ThreadLocal对象，值是Entry数组，真正存储数据的是Enter，<br>查看源码我们会发现Entry对ThreadLocal引用是弱引用<br><img src="https://img-blog.csdnimg.cn/20200424192244326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>前边说过当发生内存回收的时候，ThreadLocal会被回收，所有使用ThreadLocal后整个调用关系可用如下图描述：<br><img src="https://img-blog.csdnimg.cn/20200424192505955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当发生内存回收时，ThradLocal对象被回收，此时该对象所对应的Entry的value将会永远不会被访问，而Entry对该值是强引用，所以该value无法被回收这就造成了内存泄露。除非当线程结束时，下方的调用链就是被回收，但是我们这里使用了线程池，线程不会结束。。。那么怎么办呢？<br>其实只要在你使用完这个值，主动把这个值释放掉就可以了，代码修改比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>      localVariable.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariable</span>()); <span class="hljs-comment">//每个线程维护一个threadLocal副本</span><br>      System.out.println(<span class="hljs-string">&quot;我获取到了值，可以释放了...&quot;</span>);<br>      localVariable.remove();<br>  &#125;<br></code></pre></td></tr></table></figure><p>使用完调用remove()方法，就会释放该值，可以查看remove的源码，发现最终会调到expungeStaleEntry()释放没用的Entry。查看堆的大小就正常了<br><img src="https://img-blog.csdnimg.cn/20200424193506308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>所以，在使用线程池和ThreadLocal的时候要注意这个问题，在使用完值后一定要记得释放。</strong></p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>synchronized解决了多线程编程下的数据共享问题，而ThreadLocal则是实现了线程间的隔离。但如果使用的不好也能造成其他的问题，一定要牢记。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java并发编程-线程基础</title>
    <link href="/2022/06/26/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/06/26/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="1-线程状态及资源释放"><a href="#1-线程状态及资源释放" class="headerlink" title="1.线程状态及资源释放"></a>1.线程状态及资源释放</h3><p><img src="https://img-blog.csdnimg.cn/20200426223513824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70" alt="线程状态流转图"><br><strong>线程状态分别为新建、就绪、运行、阻塞、死亡</strong>。new一个线程时状态为新建，调用start()方法状态变为就绪，当线程获得时间片时线程进入执行状态，调用线程的yield()方法则该线程立即放弃时间片重新进入就绪状态，如果线程持有锁不会释放锁。</p><p>处于运行状态下的线程，调用对象的wait()方法则线程进入阻塞状态，直到其他线程调用对象的notify&#x2F;notifyAll方法之后被唤醒进入就绪状态。注意，wait()方法会立即释放锁，而notify&#x2F;notifyAll则不会立即释放锁，组要执行完代码块再释放所以在使用的时候最后好放在代码块的最后一行。</p><p>线程的sleep方法会抛出中断异常，但是不会释放锁。当线程执行完run方法或者调用线程的stop方法线程会死亡，但是stop方法jdk不建议使用，因为该方法不会等待线程释放锁和资源有可能造成死锁和资源浪费。如果要中断程序，建议使用interrupt()方法。<br><strong>wait()&#x2F;notify&#x2F;notifyAll方法会释放锁，但是释放的时间不同；sleep和yield不会释放锁</strong>。</p><h3 id="2-进程与线程的区别"><a href="#2-进程与线程的区别" class="headerlink" title="2.进程与线程的区别"></a>2.进程与线程的区别</h3><ol><li><strong>进程是程序运行资源分配的最小单位</strong>，也就是说操作系统封是以进程为单位进行分配资源的，资源包括cpu时间片、内存、磁盘io等；进程与进程之间是相互独立的，一个应用程序可以理解为一个进程，当你打开微信又打开支付宝的时候这两个应用都可以正常工作，所以说进程之间的独立的。进程又可以分为系统进程和用户进程，比如当你按下电脑卡机键，你就可以打开桌面，这是系统启动的进程；而你打开浏览器，这是你自己启动的进程，就是用户进程。</li><li><strong>线程是cpu调度的最小单位</strong>，线程必须依赖于进程存在，一个进程内可以有线程，所有线程共享进程的资源，线程负责执行进程的各个功能，线程本身占用很少的资源（如程序计数器）</li></ol><h3 id="3-java中有几种新启线程方式"><a href="#3-java中有几种新启线程方式" class="headerlink" title="3.java中有几种新启线程方式"></a>3.java中有几种新启线程方式</h3><p>对于这个问题大多数人可能会想到3种，继承Thread、实现Runnable接口、实现Callable接口，其实java的官方给出的答案是2种，它认为实现Runnable接口、实现Callable接口是一种方式。</p><blockquote><p><strong>There are two ways to create a new thread of execution.–Thread类第73行注释</strong></p></blockquote><p>两种启动线程的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadStart</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;myThread start....&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;myRunnable start...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyThread a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        a.start();<br><br>        MyRunnable b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b).start();<br>    &#125;<br><br>输出：<br>myThread start....<br>myRunnable start...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-对于start-方法和run-方法的理解"><a href="#4-对于start-方法和run-方法的理解" class="headerlink" title="4.对于start()方法和run()方法的理解"></a>4.对于start()方法和run()方法的理解</h3><ol><li><pre><code class="hljs">run()方法和线程的启动与否没有关系，它是具体执行业务逻辑的功能，就是一个成员方法，实例化类后可以直接调用。如下代码可以证明：</code></pre></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadStart</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;myRunnable start...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        MyRunnable b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        b.run();<br>    &#125;<br><br>&#125;<br>输出<br>myRunnable start...<br></code></pre></td></tr></table></figure><ol start="2"><li>start()方法是真正创建线程的方法，查看源码会发现它调用的start0()方法，该方法的定义*private native void start0();*实际上这个方法调用的jvm里由C语言写的方法去调操作系统的api完成线程的创建。</li></ol><h3 id="5-如何让线程安全停止"><a href="#5-如何让线程安全停止" class="headerlink" title="5.如何让线程安全停止"></a>5.如何让线程安全停止</h3><ol><li><p><strong>线程停止的方式</strong></p><ul><li>执行完run()方法，程序自然结束</li></ul><ul><li>程序抛出未处理的异常，导致终止</li></ul></li><li><p><strong>线程的暂停、恢复和停止操作（不安全）</strong></p><p> 线程的暂停、恢复和停止操作对应的API分别为<del>suspend()</del> 、<del>resume()</del> 、<del>stop</del> 。查看源码发现这些方法已经都被标注为过期不建议使用，因为这些方法都比较野蛮，不会给线程释放资源的时间，如果线程持有锁可能会导致死锁的出现。</p></li><li><p><strong>如何安全的终止线程</strong><br> <strong>interrupt()方法</strong></p></li></ol><p>Thread提供了interrupt()方法，该方法的作用是另启动一个线程给当前线程打标签（标签的值有ture和false两）；因为java中的线程是协作式的并非抢占式的，所以线程被打上中断的标签后可以不做理会。如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            String threadName=Thread.currentThread().getName();<br>            System.out.println(threadName+<span class="hljs-string">&quot; interrupt flag: &quot;</span>+isInterrupted());<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.out.println(threadName+<span class="hljs-string">&quot; is running&quot;</span>);<br>                System.out.println(threadName+<span class="hljs-string">&quot; interrupt flag: &quot;</span>+isInterrupted());<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        MyThread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        thread.interrupt();<br>    &#125;<br>&#125;<br>输出（截取一部分）：<br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">true</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">true</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>根据输出结果可以看到，即使调用了interrupt()方法，线程依然可以继续执行。</p><p><strong>监控标签值控制程序执行</strong></p><p>例如我在判断标签值之前就释放该线程的所占有的锁或者资源，这样即使线程中断也不会再持有锁和资源，不会发生死锁的情况也不会造成资源的浪费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            String threadName=Thread.currentThread().getName();<br>            System.out.println(threadName+<span class="hljs-string">&quot; interrupt flag: &quot;</span>+isInterrupted());<br><span class="hljs-comment">//            while (true) &#123;</span><br>            <span class="hljs-keyword">while</span> (!isInterrupted()) &#123;<br>                System.out.println(threadName+<span class="hljs-string">&quot; is running&quot;</span>);<br>                System.out.println(threadName+<span class="hljs-string">&quot; inner interrupt flag: &quot;</span>+isInterrupted());<br>            &#125;<br>            System.out.println(threadName+<span class="hljs-string">&quot; interrupt flag: &quot;</span>+isInterrupted());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        MyThread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">3</span>);<br>        thread.interrupt();<br>    &#125;<br><br>输出：<br>......<br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> inner interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> inner interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> inner interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> inner interrupt flag: <span class="hljs-literal">true</span><br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">true</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>isInterrupted()和Thread.interrupted的区别</strong></p><p>前者只是返回标志位的值，后者也是返回标志位的值并且把标志位的值改为false，如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            String threadName=Thread.currentThread().getName();<br>            System.out.println(threadName+<span class="hljs-string">&quot; interrupt flag: &quot;</span>+isInterrupted());<br><span class="hljs-comment">//            while (true) &#123;</span><br><span class="hljs-comment">//            while (!isInterrupted()) &#123;</span><br>            <span class="hljs-keyword">while</span> (!interrupted()) &#123;<br>                System.out.println(threadName+<span class="hljs-string">&quot; is running&quot;</span>);<br>                System.out.println(threadName+<span class="hljs-string">&quot; inner interrupt flag: &quot;</span>+isInterrupted());<br>            &#125;<br>            System.out.println(threadName+<span class="hljs-string">&quot; interrupt flag: &quot;</span>+isInterrupted());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        MyThread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">3</span>);<br>        thread.interrupt();<br>    &#125;<br>&#125;<br>输出：<br>......<br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> inner interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> inner interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> inner interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">false</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="6-yield-、priority-和join-方法"><a href="#6-yield-、priority-和join-方法" class="headerlink" title="6.yield()、priority()和join()方法"></a>6.yield()、priority()和join()方法</h3><p>为什么会把这几个方法放到一起说，因为面试的时候经常会围绕这几个方法问一些线程执行顺序的问题。<br><strong>1. yield方法</strong></p><p>yield方法是让出当前线程的cpu时间片，使线程由运行状态变为就绪状态。注意这里并不会释放资源，让出的时间也是不可以指定的。<strong>就绪状态的线程都有可能被cpu选择</strong>，举个例子：皇上有三个妃子A、B、C在等着侍寝，皇上叫A进去侍寝，中途A想到和BC共苦的日子不容易，所以就想着共同致富，于是A说自己要上厕所就出去了，但是皇上不乐意了，我乃九五至尊岂容你撒野，于是又把A叫进去了，A接着侍寝……<br><strong>2. setPriority方法</strong></p><p>priority方法是设置线程执行的优先级，根据字面理解可能会误认为优先级高的一定会在优先级低的线程之前执行，实际上不是这样的，优先级高只不过是被cpu选择的概率会大一点。验证代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YieldTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">super</span>(name);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 开始运行...&quot;</span>+i);<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">600</span>) &#123;<br>                    yield();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程一&quot;</span>);<br>        a.setPriority(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程二&quot;</span>);<br>        b.setPriority(<span class="hljs-number">10</span>);<br>        a.start();<br>        b.start();<br>    &#125;<br>&#125;<br>输出：<br>...<br>线程二 开始运行..<span class="hljs-number">.600</span><br>线程一 开始运行..<span class="hljs-number">.17</span><br>线程一 开始运行..<span class="hljs-number">.18</span><br>线程二 开始运行..<span class="hljs-number">.601</span><br>...<br>线程二 开始运行..<span class="hljs-number">.834</span><br>线程一 开始运行..<span class="hljs-number">.19</span><br>线程二 开始运行..<span class="hljs-number">.835</span><br></code></pre></td></tr></table></figure><p>从代码的输出结果看，线程二的优先级高确实执行的比较快以为被cpu选择的概率大，但cpu并不是100%选择线程二，也会选择线程一执行。所以这就验证上述结论是正确的。<br><strong>3. join方法</strong><br>join()方法是将交替执行的线程设置为顺序执行，比如在A线程中调用B的join方法，则A会等B执行完再继续执行。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Goddless</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> Thread thread;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Goddless</span><span class="hljs-params">(Thread thread)</span> &#123;<br>            <span class="hljs-built_in">this</span>.thread = thread;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;goddless 开始打饭...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>) &#123;<br>                    thread.join();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>            SleepTools.second(<span class="hljs-number">2</span>);<br>            System.out.println(<span class="hljs-string">&quot;goddles 打饭结束...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GoddlessBoyFriend</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;goddless boyfirend 开始打饭...&quot;</span>);<br>            SleepTools.second(<span class="hljs-number">2</span>);<br>            System.out.println(<span class="hljs-string">&quot;goddless boyfriend 打饭结束...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread current=Thread.currentThread();<br><br>        Thread gbf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">GoddlessBoyFriend</span>();<br><br>        Goddless goddless=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Goddless</span>(gbf);<br>        Thread g=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(goddless);<br>        g.start();<br>        gbf.start();<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 你开始打饭...&quot;</span>);<br>        g.join();<br>        SleepTools.second(<span class="hljs-number">2</span>);<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 你打饭结束...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>程序执行流程举例：</p><p>你正在打饭刚好看见女神来打饭，你让女神插队排在你的前面，正当你狡猾的露出笑容时女神看到的男朋友并让他排在女神前边打饭，女神男朋友打完饭接着女神打饭女神也打完饭两人手牵手走到了唯一的一个空座位坐下有说有笑的开始吃饭。终于轮到了你打饭，阿姨说就剩半个馒头拿走送你了…</p></blockquote><h3 id="7-守护线程"><a href="#7-守护线程" class="headerlink" title="7.守护线程"></a>7.守护线程</h3><p>Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调 度以及支持性工作。这意味着，当一个 Java 虚拟机中不存在非 Daemon 线程的 时候，Java 虚拟机将会退出。可以通过调用 Thread.setDaemon(true)将线程设置 为 Daemon 线程。我们一般用不上，比如垃圾回收线程就是 Daemon 线程。</p><p>Daemon 线程被用作完成支持性工作，但是在 Java 虚拟机退出时 Daemon 线 程中的 finally 块并不一定会执行。在构建 Daemon 线程时，不能依靠 finally 块中 的内容来确保执行关闭或清理资源的逻辑。 </p><h3 id="8-实现连接池"><a href="#8-实现连接池" class="headerlink" title="8.实现连接池"></a>8.实现连接池</h3><p>为了方便实现实现java.sql的Connection接口来获取连接，只需重写creatStatement方法和commit方法，只是简单增加点延时来代表实际的业务操作。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*拿一个数据库连接*/</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Connection <span class="hljs-title function_">fetchConnection</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlConnectionImpl</span>();<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>       SleepTools.ms(<span class="hljs-number">70</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Statement <span class="hljs-title function_">createStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>       SleepTools.ms(<span class="hljs-number">10</span>);<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>接下来定义连接池，连接池的构造函数需要一个初始化大小，连接池支支持等待超时模式即在设定的时间内没有返回连接即认为超时。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br><br><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pool</span><span class="hljs-params">(<span class="hljs-type">int</span> initialSize)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; initialSize; i++) &#123;<br>            pool.addLast(SqlConnectionImpl.fetchConnection());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">fetchConnection</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (pool) &#123;<br>            <span class="hljs-comment">/*永不超时*/</span><br>            <span class="hljs-keyword">if</span> (timeout &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">while</span> (pool.isEmpty()) &#123;<br>                    pool.wait();<br>                &#125;<br>                <span class="hljs-keyword">return</span> pool.removeFirst();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/* 超时时间 */</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.currentTimeMillis() + timeout;<br><br>                <span class="hljs-type">long</span> remain=timeout;<br><br>                <span class="hljs-keyword">while</span> (pool.isEmpty() &amp;&amp; remain &gt; <span class="hljs-number">0</span>) &#123;<br>                    pool.wait(remain);<br>                    remain = deadline - System.currentTimeMillis();<br>                &#125;<br><br>                <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (!pool.isEmpty()) &#123;<br>                    connection = pool.removeFirst();<br>                &#125;<br>                <span class="hljs-keyword">return</span> connection;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseConnection</span><span class="hljs-params">(Connection connection)</span> &#123;<br>        <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (pool) &#123;<br>                pool.addLast(connection);<br>                pool.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最后来测试这个连接池是否能够工作，启动50个线程，每个线程执行20次获取连接操作，统计超时的次数和未超时的次数。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PoolTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Pool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pool</span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">static</span> CountDownLatch end;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        AtomicInteger get;<br>        AtomicInteger notget;<br>        <span class="hljs-type">int</span> count;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(AtomicInteger get, AtomicInteger notget, <span class="hljs-type">int</span> count)</span> &#123;<br>            <span class="hljs-built_in">this</span>.get = get;<br>            <span class="hljs-built_in">this</span>.notget = notget;<br>            <span class="hljs-built_in">this</span>.count = count;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> pool.fetchConnection(<span class="hljs-number">1000</span>);<br>                    <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            connection.createStatement();<br>                            connection.commit();<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            pool.releaseConnection(connection);<br>                            get.incrementAndGet();<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        notget.incrementAndGet();<br>                        System.out.println(Thread.currentThread().getName()<br>                                + <span class="hljs-string">&quot;等待超时!&quot;</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    count--;<br>                &#125;<br><br>            &#125;<br>            end.countDown();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">threadCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>; <span class="hljs-comment">//启动的线程数</span><br>        end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(threadCount);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>; <span class="hljs-comment">//每个任务执行20次</span><br><br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">get</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(); <span class="hljs-comment">//成功获取链接</span><br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">notget</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<span class="hljs-comment">//失败获取链接</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(get, notget, count), <span class="hljs-string">&quot;work_&quot;</span> + i).start();<br>        &#125;<br>        end.await();<br>        System.out.println(<span class="hljs-string">&quot;请求执行的总次数: &quot;</span> + threadCount * count);<br>        System.out.println(<span class="hljs-string">&quot;获取到链接的次数: &quot;</span> + get);<br>        System.out.println(<span class="hljs-string">&quot;没有获取到链接的次数: &quot;</span> + notget);<br>    &#125;<br>&#125;<br><br>执行结果：<br>......<br>work_22等待超时!<br>work_7等待超时!<br>work_41等待超时!<br>work_39等待超时!<br>work_25等待超时!<br>work_33等待超时!<br>请求执行的总次数: <span class="hljs-number">1000</span><br>获取到链接的次数: <span class="hljs-number">857</span><br>没有获取到链接的次数: <span class="hljs-number">143</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法介绍</title>
    <link href="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="排序算法概述"><a href="#排序算法概述" class="headerlink" title="排序算法概述"></a>排序算法概述</h3><p>排序是将一组对象按照某种逻辑顺序重新排列过程。比如，订单按照日期排序，这种排序很可能使用了某种排序算法。现在计算机的使用很广泛，随之差生的数据无处不在，而整理数据的第一步通常就是排序。</p><p>十大排序算法：冒泡排序、选择排序、插入排序、归并排序、堆排序、快速排序、希尔排序、计数排序、基数排序、桶排序</p><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><p>一种简单的排序算法。它反复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。这个工作重复地进行直到没有元素再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为元素会经由交换慢慢“浮”到数列的顶端。 </p><p><strong>操作步骤</strong></p><ol><li>从数组头开始，比较相邻的元素。如果第一个比第二个大(小)，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到尾部的最后一对，这样在最后的元素应该会是最大(小)的数；</li><li>重复步骤1~2，重复次数等于数组的长度，直到排序完成。</li></ol><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" class="" title="冒泡排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array) &#123;<br><br>    <span class="hljs-keyword">if</span> (array.length&lt;<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (array[j]&gt;array[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-type">int</span> temp=array[j+<span class="hljs-number">1</span>];<br>                array[j+<span class="hljs-number">1</span>]=array[j];<br>                array[j]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><p><strong>操作步骤</strong></p><ol><li>首先，找到数组中最大（小）的那个元素</li><li>其次，将它和数组的第一个元素交换位置（如果第一个元素就是最大（小）元素那么它就和自己交换）</li><li>再次，在剩下的元素中找到最大（小）的元素，将它与数组的第二个元素交换位置</li><li>如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最大（小）者</li></ol><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" class="" title="选择排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array)&#123;<br><br>    <span class="hljs-keyword">if</span> (array.length&lt;<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        <span class="hljs-type">int</span> min=i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; array.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (array[j]&lt;array[min]) &#123;<br>                min=j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> temp=array[i];<br>        array[i]=array[min];<br>        array[min]=temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><p>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。为了给要插入的元素腾出空间，我们需要将插入位置之后的已排序元素在都向后移动一位。插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快得多。总的来说，插入排序对于部分有序的数组十分高效，也很适合小规模数组</p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" class="" title="插入排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array) &#123;<br>    <span class="hljs-keyword">if</span> (array.length&lt;<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        <span class="hljs-type">int</span> currentValue=array[i];<br>        <span class="hljs-type">int</span> preIndex=i-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; array[preIndex] &gt; currentValue) &#123;<br>            array[preIndex+<span class="hljs-number">1</span>]=array[preIndex];<br>            preIndex--;<br>        &#125;<br>        array[preIndex+<span class="hljs-number">1</span>]=currentValue;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h3><p>一种基于<strong>插入排序</strong>的快速的排序算法。简单插入排序对于大规模乱序数组很慢，因为元素只能一点一点地从数组的一端移动到另一端。例如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需要N-1 次移动。</p><p>希尔排序为了加快速度简单地改进了插入排序，也称为缩小增量排序，同时该算法是突破O(n^2）的第一批算法之一。</p><p>希尔排序是把待排序数组按一定数量的分组，对每组使用直接插入排序算法排序；然后缩小数量继续分组排序，随着数量逐渐减少，每组包含的元素越来越多，当数量减至 1 时，整个数组恰被分成一组，排序便完成了。这个不断缩小的数量，就构成了一个增量序列。</p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" class="" title="希尔排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array)&#123;<br><br>    <span class="hljs-type">int</span> len=array.length;<br>    <span class="hljs-comment">// 确定分组步长，逐渐减小直至未1，此时整个数组排序完成</span><br>    <span class="hljs-type">int</span> gap=len/<span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">while</span> (gap&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=gap;i&lt;len;i++)&#123; <span class="hljs-comment">//当前元素与组内已有元素对比</span><br>            <span class="hljs-type">int</span> currentValue=array[i];<br>            <span class="hljs-type">int</span> preIndex=i-gap; <span class="hljs-comment">//组内的前一个元素索引</span><br>            <span class="hljs-keyword">while</span> (preIndex&gt;=<span class="hljs-number">0</span> &amp;&amp; array[preIndex]&gt;currentValue)&#123;<br>                array[preIndex+gap]=array[preIndex];<br>                preIndex=preIndex-gap;<br>            &#125;<br>            array[preIndex+gap]=currentValue;<br>        &#125;<br>        gap=gap/<span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。对于给定的一组数据，利用递归与分治技术将数据序列划分成为越来越小的半子表，在对半子表排序后，再用递归方法将排好序的半子表合并成为越来越大的有序序列。为了提升性能，有时我们在半子表的个数小于某个数（比如15）的情况下，对半子表的排序采用其他排序算法，比如插入排序。若将两个有序表合并成一个有序表，称为2-路归并，与之对应的还有多路归并。</p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" class="" title="归并排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array) &#123;<br>    <span class="hljs-keyword">if</span> (array.length &lt; <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">//只有一个元素的时候说明已是最小粒度，开始合并</span><br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> array.length / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span>[] left = Arrays.copyOfRange(array, <span class="hljs-number">0</span>, mid);<br>    <span class="hljs-type">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);<br>    <span class="hljs-keyword">return</span> merge(sort(left), sort(right));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] merge(<span class="hljs-type">int</span>[] left, <span class="hljs-type">int</span>[] right) &#123;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[left.length + right.length];<br>    <span class="hljs-type">int</span> index, leftIndex, rightIndex;<br>    <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>, leftIndex = <span class="hljs-number">0</span>, rightIndex = <span class="hljs-number">0</span>; index &lt; result.length; index++) &#123;<br>        <span class="hljs-keyword">if</span> (leftIndex &gt;= left.length) &#123; <span class="hljs-comment">//如果左边已经全排完，右队列依次填入结果</span><br>            result[index] = right[rightIndex++];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightIndex &gt;= right.length) &#123;<span class="hljs-comment">//如果右边已经全排完，左队列依次填入结果</span><br>            result[index] = left[leftIndex++];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left[leftIndex] &gt; right[rightIndex]) &#123;<br>            result[index] = right[rightIndex++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result[index] = left[leftIndex++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h3><p>快速排序（Quicksort）是对冒泡排序的一种改进，也是采用分治法的一个典型的应用。首先任意选取一个数据（比如数组的第一个数）作为关键数据，我们称为基准数(Pivot)，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序，也称为分区（partition）操作。通过一趟快速排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数组变成有序序列。为了提升性能，有时我们在分割后独立的两部分的个数小于某个数（比如15）的情况下，会采用其他排序算法，比如插入排序。</p><p><strong>基准的选取</strong>：最优的情况是基准值刚好取在无序区数值的中位数，这样能够最大效率地让两边排序，同时最大地减少递归划分的次数，但是一般很难做到最优。基准的选取一般有三种方式，选取数组的第一个元素，选取数组的最后一个元素，以及选取第一个、最后一个以及中间的元素的中位数（如4 5 6 7, 第一个4, 最后一个7, 中间的为5, 这三个数的中位数为５, 所以选择5作为基准）。Dual-Pivot快排：双基准快速排序算法，其实就是用两个基准数, 把整个数组分成三份来进行快速排序，在这种新的算法下面，比经典快排从实验来看节省了10%的时间。</p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" class="" title="快速排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end) &#123;<br>    <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span> || end &lt; <span class="hljs-number">0</span> || start &gt; end || array.length &lt; <span class="hljs-number">1</span> || end &gt;= array.length || start&gt;=array.length) &#123; <span class="hljs-comment">//数组为1结束</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> array[end]; <span class="hljs-comment">//取最后一个元素为基数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">zoneIndex</span> <span class="hljs-operator">=</span> start - <span class="hljs-number">1</span>; <span class="hljs-comment">//分区指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>        <span class="hljs-keyword">if</span> (array[i] &lt;= pivot) &#123;<br>            zoneIndex++;<br>            <span class="hljs-keyword">if</span> (i &gt; zoneIndex) &#123;<br>                swap(array, i, zoneIndex);<br>            &#125;<br>        &#125;<br>    &#125;<br>   <br>    <span class="hljs-keyword">if</span> (zoneIndex &gt; start) &#123;<br>        sort(array, start, zoneIndex - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (zoneIndex &lt; end) &#123;<br>        sort(array, zoneIndex + <span class="hljs-number">1</span>, end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[to];<br>    array[to] = array[from];<br>    array[from] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h3><p>许多应用程序都需要处理有序的元素，但不一定要求他们全部有序，或者不一定要一次就将他们排序，很多时候，我们每次只需要操作数据中的最大元素（最小元素），那么有一种基于二叉堆的数据结构可以提供支持。所谓二叉堆，是一个完全二叉树的结构，同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。在一个二叉堆中，根节点总是最大（或者最小）节点。堆排序算法就是抓住了这一特点，每次都取堆顶的元素，然后将剩余的元素重新调整为最大（最小）堆，依次类推，最终得到排序的序列。</p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E4%BA%8C%E5%8F%89%E6%A0%91.png" class="" title="二叉树"><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%A0%86%E6%8E%92%E5%BA%8F.png" class="" title="堆排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> len;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array) &#123;<br>    len = array.length;<br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>    buildMaxHeap(array);<br><br>    <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">1</span>) &#123;<br>        swap(array, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>        len--;<br>        adjustHeap(array, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        adjustHeap(array, i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxIndex</span> <span class="hljs-operator">=</span> i;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * (i + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (left &lt; len &amp;&amp; array[left] &gt; array[maxIndex]) &#123;<br>        maxIndex = left;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (right &lt; len &amp;&amp; array[right] &gt; array[maxIndex]) &#123;<br>        maxIndex = right;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (maxIndex != i) &#123;<br>        swap(array, maxIndex, i);<br>        adjustHeap(array, maxIndex);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[to];<br>    array[to] = array[from];<br>    array[from] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h3><p>计数排序对一定范围内的整数排序时候的速度非常快，一般快于其他排序算法。但计数排序局限性比较大，只限于对整数进行排序，而且待排序元素值分布较连续、跨度小的情况。计数排序是一个排序时不比较元素大小的排序算法。如果一个数组里所有元素都是整数，而且都在0-K以内。对于数组里每个元素来说，如果能知道数组里有多少项小于或等于该元素，就能准确地给出该元素在排序后的数组的位置。</p><p>实际应用中我们会同时找出数组中的max和min，主要是为了尽量节省空间。试想[1003, 1001, 1030, 1050]这样的数据要排序，真的需要建立长度为1050 + 1的数组吗？我们只需要长度为1050 - 1003 + 1&#x3D; 48的数组（先不考虑额外+1的长度），就能囊括从最小到最大元素之间的所有元素了。如果待排序数组的元素值跨度很大，比如[99999, 1, 2]，为三个元素排序要使用99999 - 1 + 1的空间，实在是浪费。<strong>所以计数排序适用于待排序元素值分布较连续、跨度小的情况。</strong></p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.png" class="" title="计数排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array)&#123;<br>    <span class="hljs-type">int</span> len=array.length;<br>    <span class="hljs-keyword">if</span> (len&lt;<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-type">int</span> min=array[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> max=array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (array[i]&gt;max)&#123;<br>            max=array[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (array[i]&lt;min)&#123;<br>            min=array[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> bias=<span class="hljs-number">0</span>-min; <span class="hljs-comment">//偏移量，为了把原始数组中最小值映射到计数数组的0起始位置</span><br>    <span class="hljs-type">int</span>[] countArray=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max-min+<span class="hljs-number">1</span>];<br>    Arrays.fill(countArray,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//遍历数组，将原始数组元素映射到计数数组的下标位置，并计数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        countArray[bias+array[i]]++;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;计数数组为：&quot;</span>);<br>    PrintArray.print(countArray);<br><br>    <span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>; <span class="hljs-comment">//原始数组的起始位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; countArray.length; i++) &#123;<br>        <span class="hljs-keyword">while</span> (countArray[i]&gt;<span class="hljs-number">0</span>)&#123;<br>            countArray[i]--;<br>            array[pos]=i-bias;<br>            pos++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9.桶排序"></a>9.桶排序</h3><p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，利用某种函数的映射关系将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序）。 </p><p>桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做排序即可。</p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E6%A1%B6%E6%8E%92%E5%BA%8F.png" class="" title="桶排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketSort</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array      待排序数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketSize 桶容量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; <span class="hljs-title function_">sort</span><span class="hljs-params">(ArrayList&lt;Integer&gt; array, <span class="hljs-type">int</span> bucketSize)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;arraySize:&quot;</span>+array.size()+<span class="hljs-string">&quot;, bucketSize:&quot;</span>+bucketSize);<br>        <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.size() &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> array;<br>        &#125;<br><br>        <span class="hljs-type">int</span> len=array.size();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> array.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> array.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (array.get(i) &gt; max) &#123;<br>                max = array.get(i);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (array.get(i) &lt; min) &#123;<br>                min = array.get(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*初始化桶容器*/</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bucketCount</span> <span class="hljs-operator">=</span> (max - min) / bucketSize + <span class="hljs-number">1</span>;<br>        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(bucketCount); <span class="hljs-comment">//初始化桶个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>            bucketArr.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        &#125;<br><br>        <span class="hljs-comment">/*数据放入每个桶中*/</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));<br>        &#125;<br><br>        <span class="hljs-comment">/*查看桶中数据存放情况*/</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketArr.size(); i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;第【&quot;</span>+i+<span class="hljs-string">&quot;】个桶中的元素是：&quot;</span>);<br>            ArrayList&lt;Integer&gt; list=bucketArr.get(i);<br>            Iterator&lt;Integer&gt; iterator=list.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>                System.out.print(iterator.next()+<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br><br>        ArrayList&lt;Integer&gt; resultArr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketArr.size(); i++) &#123;<br>            ArrayList&lt;Integer&gt; list=bucketArr.get(i);<br>            <span class="hljs-keyword">if</span> (list.size()&gt;<span class="hljs-number">1</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;第【&quot;</span>+i+<span class="hljs-string">&quot;]个桶元素需要重新排序&quot;</span>);<br>                list=sort(list,bucketSize/<span class="hljs-number">2</span>);<br>            &#125;<br>            Iterator&lt;Integer&gt; iterator=list.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>                resultArr.add(iterator.next());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resultArr;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        Integer[] array=&#123;4,6,8,9,2,17,25&#125;;</span><br>        ArrayList&lt;Integer&gt; SRC=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        SRC.add(<span class="hljs-number">4</span>);<br>        SRC.add(<span class="hljs-number">9</span>);<br>        SRC.add(<span class="hljs-number">17</span>);<br>        SRC.add(<span class="hljs-number">8</span>);<br>        SRC.add(<span class="hljs-number">6</span>);<br>        SRC.add(<span class="hljs-number">25</span>);<br>        SRC.add(<span class="hljs-number">2</span>);<br>        PrintArray.print(SRC);<br>        System.out.println(<span class="hljs-string">&quot;======================================&quot;</span>);<br>        ArrayList&lt;Integer&gt; res= BucketSort.sort(SRC,<span class="hljs-number">4</span>);<br>        PrintArray.print(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h3><p>常见的数据元素一般是由若干位组成的，比如字符串由若干字符组成，整数由若干位0至9数字组成。基数排序按照从右往左的顺序，依次将每一位都当做一次关键字，然后按照该关键字对数组排序，同时每一轮排序都基于上轮排序后的结果；当我们将所有的位排序后，整个数组就达到有序状态。基数排序不是基于比较的算法。基数是什么意思？对于十进制整数，每一位都只可能是09中的某一个，总共10种可能。那10就是它的基，同理二进制数字的基为2；对于字符串，如果它使用的是8位的扩展ASCII字符集，那么它的基就是256</p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png" class="" title="基数排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 整数排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RadixSortInt</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array) &#123;<br>        <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> array;<br>        &#125;<br>        <span class="hljs-comment">/*找出最大数*/</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; array.length; i++) &#123;<br>            max = Math.max(max, array[i]);<br>        &#125;<br><br>        <span class="hljs-comment">/*先算出最大数的位数*/</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDigit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>            max /= <span class="hljs-number">10</span>;<br>            maxDigit++;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, div = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/*构建桶*/</span><br>        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            bucketList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        &#125;<br>        <span class="hljs-comment">/*按照从右往左的顺序，依次将每一位都当做一次关键字，然后按照该关键字对数组排序，</span><br><span class="hljs-comment">        每一轮排序都基于上轮排序后的结果*/</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maxDigit; i++, mod *= <span class="hljs-number">10</span>, div *= <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-comment">/*遍历原始数组，投入桶中*/</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (array[j] % mod) / div;<br>                bucketList.get(num).add(array[j]);<br>            &#125;<br>            <span class="hljs-comment">/*桶中的数据写回原始数组，清除桶，准备下一轮的排序*/</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; bucketList.size(); j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; bucketList.get(j).size(); k++) &#123;<br>                    array[index++] = bucketList.get(j).get(k);<br>                &#125;<br>                bucketList.get(j).clear();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span>[] SRC = &#123;<span class="hljs-number">86</span>, <span class="hljs-number">11</span>, <span class="hljs-number">77</span>, <span class="hljs-number">22</span>, <span class="hljs-number">32</span>, <span class="hljs-number">45</span>, <span class="hljs-number">58</span>, <span class="hljs-number">63</span>, <span class="hljs-number">93</span>, <span class="hljs-number">4</span>, <span class="hljs-number">37</span>, <span class="hljs-number">23</span>&#125;;<br>        PrintArray.print(SRC);<br>        System.out.println(<span class="hljs-string">&quot;============================================&quot;</span>);<br>        <span class="hljs-type">int</span>[] dest = RadixSortInt.sort(PrintArray.SRC);<br>        PrintArray.print(dest);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符串排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RadixSortString</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  ArrayList&lt;String&gt; <span class="hljs-title function_">sort</span><span class="hljs-params">(ArrayList&lt;String&gt; arrayList)</span>&#123;<br>        <span class="hljs-keyword">if</span> (arrayList==<span class="hljs-literal">null</span> || arrayList.size()&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> arrayList;<br>        &#125;<br><br>        <span class="hljs-comment">/*获取最大长度字符串，决定需要遍历几次*/</span><br>        <span class="hljs-type">int</span> maxLen=arrayList.get(<span class="hljs-number">0</span>).length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrayList.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (arrayList.get(i).length()&gt;maxLen)&#123;<br>                maxLen=arrayList.get(i).length();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/*初始化桶*/</span><br>        ArrayList&lt;ArrayList&lt;String&gt;&gt; bucketArr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">128</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++) &#123;<br>            bucketArr.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;());<br>        &#125;<br><br>        <span class="hljs-type">int</span> round=<span class="hljs-number">1</span>; <span class="hljs-comment">//比较轮数</span><br>        <span class="hljs-keyword">while</span> (round&lt;=maxLen)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arrayList.size(); j++) &#123;<br>                <span class="hljs-type">int</span> len=arrayList.get(j).length();<br>                <span class="hljs-keyword">if</span> (len&gt;=round)&#123;<br>                    bucketArr.get(arrayList.get(j).charAt(len-round)).add(arrayList.get(j));<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    bucketArr.get(arrayList.get(j).charAt(<span class="hljs-number">0</span>)).add(arrayList.get(j));<br>                &#125;<br>            &#125;<br><br>            arrayList.clear(); <span class="hljs-comment">//清除旧数据，重新放入元素</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketArr.size(); i++) &#123;<br>                <span class="hljs-keyword">if</span> (bucketArr.get(i).size()&gt;<span class="hljs-number">0</span>)&#123;<br>                    Iterator&lt;String&gt; iterator=bucketArr.get(i).iterator();<br>                    <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>                        arrayList.add(iterator.next());<br>                    &#125;<br>                    bucketArr.get(i).clear(); <span class="hljs-comment">//清除每个桶的数据</span><br>                &#125;<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;当前是第【&quot;</span>+round+<span class="hljs-string">&quot;]轮，结果为：&quot;</span>);<br>            PrintArray.print(arrayList);<br>            round++; <span class="hljs-comment">//进入下一轮</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> arrayList;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; SRC=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        SRC.add(<span class="hljs-string">&quot;bcde&quot;</span>);<br>        SRC.add(<span class="hljs-string">&quot;fhgs&quot;</span>);<br>        SRC.add(<span class="hljs-string">&quot;e&quot;</span>);<br>        SRC.add(<span class="hljs-string">&quot;dasdegj&quot;</span>);<br>        SRC.add(<span class="hljs-string">&quot;abd&quot;</span>);<br>        SRC.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        SRC.add(<span class="hljs-string">&quot;epvrs&quot;</span>);<br>        SRC.add(<span class="hljs-string">&quot;gpoweewr&quot;</span>);<br>        PrintArray.print(SRC);<br>        System.out.println(<span class="hljs-string">&quot;======================================&quot;</span>);<br>        ArrayList&lt;String&gt; res= RadixSortString.sort(SRC);<br>        PrintArray.print(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>基数排序有两种方法：</p><ul><li>MSD 从高位开始进行排序</li><li>LSD 从低位开始进行排序</li></ul><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><h3 id="11-外部排序"><a href="#11-外部排序" class="headerlink" title="11.外部排序"></a>11.外部排序</h3><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F.png" class="" title="外部排序"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>排序算法</th><th><strong>平均时间复杂度</strong></th><th><strong>最好情况</strong></th><th><strong>最坏情况</strong></th><th><strong>空间复杂度</strong></th><th><strong>稳定性</strong></th><th><strong>比较算法</strong></th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td><td>是</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td><td>是</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td><td>是</td></tr><tr><td>希尔排序</td><td>不确定</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td><td>是</td></tr><tr><td>归并排序</td><td>O(nlog n)</td><td>O(nlog n)</td><td>O(nlog n)</td><td>O(n)</td><td>稳定</td><td>是</td></tr><tr><td>快速排序</td><td>O(nlog n)</td><td>O(nlog n)</td><td>O(n^2)</td><td>O(log n)</td><td>不稳定</td><td>是</td></tr><tr><td>堆排序</td><td>O(nlog n)</td><td>O(nlog n)</td><td>O(nlog n)</td><td>O(1)</td><td>不稳定</td><td>是</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>稳定</td><td>否</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n^2)</td><td>O(n+k)</td><td>稳定</td><td>否</td></tr><tr><td>基数排序</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n+k)</td><td>稳定</td><td>否</td></tr></tbody></table><p><strong>算法稳定性</strong></p><ul><li><p>稳定：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面；</p></li><li><p>不稳定：如果a原本在b的前面，而a&#x3D;b，排序之后a可能会出现在b的后面；</p></li><li><p>排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。</p></li></ul><p><strong>算法复杂度</strong></p><ul><li>算法的复杂度往往取决于数据的规模大小和数据本身分布性质。</li><li>时间复杂度： 一个算法执行所耗费的时间。</li><li>空间复杂度：对一个算法在运行过程中临时占用存储空间大小的量度。</li><li>常见复杂度由小到大：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n)</li></ul><p>在各种不同算法中，若算法中语句执行次数(占用空间)为一个常数，则复杂度为O(1)；当一个算法的复杂度与以2为底的n的对数成正比时，可表示为O(log n)；当一个算法的复杂度与n成线性比例关系时，可表示为O (n)，依次类推。</p><p><strong>时间复杂度记忆</strong> </p><ul><li>冒泡、选择、插入排序需要两个for循环，每次只关注一个元素，平均时间复杂度为**O(n^2)**（一遍找元素O(n)，一遍找位置O(n)）</li><li>快速、归并、堆基于分治思想，log以2为底，平均时间复杂度往往和O(nlogn)（一遍找元素O(n)，一遍找位置O(logn)）相关</li><li>而希尔排序依赖于所取增量序列的性质，但是到目前为止还没有一个最好的增量序列 。例如希尔增量序列时间复杂度为O(n²)，有人在大量的实验后得出结论：<strong>当n在某个特定的范围后希尔排序的最小时间复杂度大约为n^1.3</strong>。</li></ul><p><strong>从平均时间来看，快速排序是效率最高的</strong>：快速排序中平均时间复杂度O(nlog n)，这个公式中隐含的常数因子很小，比归并排序的O(nlog n)中的要小很多，所以大多数情况下，快速排序总是优于合并排序的。</p><p>而堆排序的平均时间复杂度也是O(nlog n)，但是堆排序存在着重建堆的过程，它把根节点移除后，把最后的叶子结点拿上来后需要重建堆，但是，拿上的值是要比它的两个叶子结点要差很多的，一般要比较很多次，才能回到合适的位置。堆排序就会有很多的时间耗在堆调整上。</p><p>虽然快速排序的最坏情况为排序规模（n）的平方关系，但是这种最坏情况取决于每次选择的基准， 对于这种情况，已经提出了很多优化的方法，比如三取样划分和Dual-Pivot快排。同时，当排序规模较小时，划分的平衡性容易被打破，而且频繁的方法调用超过了O(nlog n)为O(n^2)省出的时间，所以一般排序规模较小时，会改用插入排序或者其他排序算法。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/24/hello-world/"/>
    <url>/2022/06/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
