<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>terminal配置git</title>
    <link href="/2022/06/27/terminal%E9%85%8D%E7%BD%AEgit/"/>
    <url>/2022/06/27/terminal%E9%85%8D%E7%BD%AEgit/</url>
    
    <content type="html"><![CDATA[<p>老话说在前头：工欲善其事，必先利其器。想要玩转 macOS 的终端，想要用的顺手、看着高端，折腾是必不可少的。</p><h3 id="第一步，安装-HomeBrew"><a href="#第一步，安装-HomeBrew" class="headerlink" title="第一步，安装 HomeBrew"></a><strong>第一步，安装 <a href="https://brew.sh/index_zh-cn.html">HomeBrew</a></strong></h3><p>作为 macOS 必备的包管理工具，相信大家肯定已经很熟悉了，没安装的朋友可以执行下面命令装一下，安装过的可以执行下面命令可以进行更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/bin/ruby -e <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL &lt;https://raw.githubusercontent.com/Homebrew/install/master/install&gt;)</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="第二步，更新-zsh、git"><a href="#第二步，更新-zsh、git" class="headerlink" title="第二步，更新 zsh、git"></a><strong>第二步，更新 zsh、git</strong></h3><p>macOS 一般会自带 zsh，不过版本会比较早，我们先更新一下，以便使用最新特性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install zsh<br><br>==&gt; Downloading &lt;https://homebrew.bintray.com/bottles/zsh-5.7.1.high_sierra.bottle.tar.gz&gt;<br><span class="hljs-comment">######################################################################## 100.0%</span><br>==&gt; Pouring zsh-5.7.1.high_sierra.bottle.tar.gz<br>/usr/local/Cellar/zsh/5.7.1: 1,515 files, 13.3MB<br></code></pre></td></tr></table></figure><h3 id="第三步，切换至-zsh-并安装-oh-my-zsh"><a href="#第三步，切换至-zsh-并安装-oh-my-zsh" class="headerlink" title="第三步，切换至 zsh 并安装 oh-my-zsh"></a><strong>第三步，切换至 zsh 并安装 oh-my-zsh</strong></h3><p>查看当前使用的 shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span><br><br>/bin/bash<br></code></pre></td></tr></table></figure><p>查看安装的 shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/shells<br><br>/bin/bash<br>/bin/csh<br>/bin/ksh<br>/bin/sh<br>/bin/tcsh<br>/bin/zsh<br></code></pre></td></tr></table></figure><p>切换为 zsh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chsh -s /bin/zsh<br></code></pre></td></tr></table></figure><p>重启终端即可使用 zsh。</p><p>接下来安装 oh-my-zsh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL &lt;https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh&gt;)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>安装完成后，终端展示如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">  ____  / /_     ____ ___  __  __   ____  _____/ /_<br> / __ \\/ __ \\   / __ `__ \\/ / / /  /_  / / ___/ __ \\<br>/ /_/ / / / /  / / / / / / /_/ /    / /_(__  ) / / /<br>\\____/_/ /_/  /_/ /_/ /_/\\__, /    /___/____/_/ /_/<br>                        /____/                       ....is now installed!<br><br>Please look over the ~/.zshrc file to select plugins, themes, and options.<br><br>p.s. Follow us at &lt;https://twitter.com/ohmyzsh&gt;.<br><br>p.p.s. Get stickers and t-shirts at &lt;http://shop.planetargon.com&gt;.<br></code></pre></td></tr></table></figure><h3 id="第四步，配置-oh-my-zsh"><a href="#第四步，配置-oh-my-zsh" class="headerlink" title="第四步，配置 oh-my-zsh"></a><strong>第四步，配置 oh-my-zsh</strong></h3><p>看到这里，安装流程已经完毕啦，执行最后的配置，就可以进行体验了。</p><p>打开 oh-my-zsh 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打开 zshrc 文件进行编辑，也可以使用 vim 编辑器</span><br>open ~/.zshrc<br><span class="hljs-comment"># 本人使用的是 vs code</span><br>open ~/.zshrc -a Visual\\ Studio\\ Code<br></code></pre></td></tr></table></figure><p><strong>主题</strong></p><p>配置项 <code>ZSH_THEME</code> 即为 oh-my-zsh 的主题配置，oh-my-zsh 的 GitHub Wiki 页面提供了 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes">主题列表</a>当设置为 <code>ZSH_THEME=random</code> 时，每次打开终端都会使用一种随机的主题。</p><p><strong>插件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">plugins=(git osx autojump zsh-autosuggestions zsh-syntax-highlighting)<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>其中 zsh-autosuggestions 和 zsh-syntax-highlighting 是自定义安装的插件，需要用 git 将插件 clone 到指定插件目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 自动提示插件</span><br>git <span class="hljs-built_in">clone</span> &lt;https://github.com/zsh-users/zsh-autosuggestions.git&gt; <span class="hljs-variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions<br><span class="hljs-comment"># 语法高亮插件</span><br>git <span class="hljs-built_in">clone</span> &lt;https://github.com/zsh-users/zsh-syntax-highlighting.git&gt; <span class="hljs-variable">$ZSH_CUSTOM</span>/plugins/zsh-syntax-highlighting<br></code></pre></td></tr></table></figure><p>需要其他插件的可以自行安装，如果插件未安装，开启终端的时候会报错，按照错误提示，安装对应的插件即可。</p><p>更新配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><p>更新完配置即可生效，不想更新配置的话，新开一个终端同样可以生效。</p><p>正所谓风雨之后见彩虹，经过这一番捣鼓，电脑用起来更加顺手了，可以愉快的开发了。</p>]]></content>
    
    
    <categories>
      
      <category>机器配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zsh、git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java并发编程-wait、notify、notifyAll</title>
    <link href="/2022/06/26/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-wait%E3%80%81notify%E3%80%81notifyAll/"/>
    <url>/2022/06/26/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-wait%E3%80%81notify%E3%80%81notifyAll/</url>
    
    <content type="html"><![CDATA[<p><strong>首先说以下这个几个方法归属，这几个方法并不是Thread类的方法，而是Object的方法，只是在多线程编程中实现线程间同步用到而已。</strong></p><h3 id="一、方法的作用"><a href="#一、方法的作用" class="headerlink" title="一、方法的作用"></a>一、方法的作用</h3><h4 id="1-wait-方法"><a href="#1-wait-方法" class="headerlink" title="1.wait()方法"></a>1.wait()方法</h4><p>如果某个线程调用的对象的wait()方法，那么该线程会进入到该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p><h4 id="2-notify-x2F-notifyAll方法"><a href="#2-notify-x2F-notifyAll方法" class="headerlink" title="2.notify&#x2F;notifyAll方法"></a>2.notify&#x2F;notifyAll方法</h4><p>当某个线程调用了对象的notify方法，那么会在该对象的等待池中唤醒一个线程进入到锁池中，锁池中的线程是可以参与竞争对象的锁的。notifyAll方法则是唤醒所有等待池中的方法进入到等待池中。当该线程执行完run方法后释放对象的锁，则所有锁池中的线程开始竞争锁，其他未竞争到锁的线程仍旧会在锁池中等待下一次锁释放。</p><h3 id="二、wait-notify编程的标准范式"><a href="#二、wait-notify编程的标准范式" class="headerlink" title="二、wait\notify编程的标准范式"></a>二、wait\notify编程的标准范式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Object o=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">synchronized</span>(o)&#123;<br><span class="hljs-keyword">while</span>(condition 不满足条件)&#123;<br>o.wait();<br>&#125;<br><span class="hljs-keyword">do</span> sth;<br>&#125;<br><br><span class="hljs-keyword">synchronized</span>(o)&#123;<br>change condition;<br>o.notify()/o.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、面试题"><a href="#三、面试题" class="headerlink" title="三、面试题"></a>三、面试题</h3><p><strong>问题：让两个线程交替打印0-100</strong></p><p>首先我们定义一个打印机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderPrint</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> number;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-built_in">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Oushu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-keyword">while</span> (number &lt; <span class="hljs-number">101</span> &amp;&amp; thread.isInterrupted() == <span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">if</span> (number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(thread.getName() + <span class="hljs-string">&quot;print: &quot;</span> + number);<br>                number++;<br>                SleepTools.ms(<span class="hljs-number">100</span>);<br>                notify();<br>                <span class="hljs-keyword">if</span> (number == <span class="hljs-number">101</span>) &#123; <span class="hljs-comment">// 判断是否已打印最后一个数字，如果是则通知线程你该关闭了</span><br>                    thread.interrupt();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">//                    e.printStackTrace();</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;偶数打印完毕, &quot;</span>+thread.getName()+<span class="hljs-string">&quot;==结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Jishu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-keyword">while</span> (number &lt; <span class="hljs-number">101</span> &amp;&amp; thread.isInterrupted() == <span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">if</span> (number % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                System.out.println(thread.getName() + <span class="hljs-string">&quot;print: &quot;</span> + number);<br>                number++;<br>                SleepTools.ms(<span class="hljs-number">100</span>);<br>                notify();<br>                <span class="hljs-keyword">if</span> (number == <span class="hljs-number">99</span>) &#123;   <span class="hljs-comment">// 判断是否已打印最后一个数字，如果是则通知线程你该关闭了</span><br>                    thread.interrupt();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;奇数打印完毕, &quot;</span> + thread.getName() + <span class="hljs-string">&quot;==结束&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再定义两个线程，分别打印奇数和偶数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderPrintTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> OrderPrint orderPrint=<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderPrint</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OushuRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            orderPrint.Oushu();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">500</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JishuRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            orderPrint.Jishu();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">500</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JishuRunnable</span>()).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OushuRunnable</span>()).start();<br>    &#125;<br>&#125;<br><br>输出：<br>。。。<br>Thread-1print: <span class="hljs-number">94</span><br>Thread-0print: <span class="hljs-number">95</span><br>Thread-1print: <span class="hljs-number">96</span><br>Thread-0print: <span class="hljs-number">97</span><br>Thread-1print: <span class="hljs-number">98</span><br>Thread-0print: <span class="hljs-number">99</span><br>Thread-1print: <span class="hljs-number">100</span><br>偶数打印完毕, Thread-<span class="hljs-number">1</span>==结束<br>奇数打印完毕, Thread-<span class="hljs-number">0</span>==结束<br></code></pre></td></tr></table></figure><p><strong>代码分析</strong>：<br>启动两个线程一起竞争打印机的锁，其中一个线程获取到锁后执行打印前先判断当前数字是否是我的业务范围，如果是：打印这个数字，判断是不是我需要打印的最后一个数字，接着进入wait()状态。</p><ol><li>为社么要判断是不是最后一个数字？<br>假设没有这个判断，奇数打印完99之后number&#x3D;100，然后进入wait状态；偶数打印完100之后number&#x3D;101，通知奇数线程启动，奇数判断不符合条件结束线程。此时偶数线程还处在wait状态，导致线程不能被唤醒，一直处于wait状态。这里关于interrupt的用法可以参考之前的文章。</li><li>线程执行notify之后可能还会拿到锁吗？<br>亲身实验过了，以为调用notify之后并没有执行对象的wait方法，该方法执行完任务之后还是会进入到锁池和被唤醒的线程一起去争夺锁。即使再拿到锁，不符合要求会调用对象的wait方法，使线程再进入到wait状态。</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java并发编程-synchronized、volatile和threadlocal</title>
    <link href="/2022/06/26/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-synchronized%E3%80%81volatile%E5%92%8CThread-Local/"/>
    <url>/2022/06/26/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-synchronized%E3%80%81volatile%E5%92%8CThread-Local/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Synchroinzed锁"><a href="#一、Synchroinzed锁" class="headerlink" title="一、Synchroinzed锁"></a>一、<strong>Synchroinzed锁</strong></h3><p>synchroinzed锁又称为内置锁，之前提到过进程中的线程是共享进程内所有资源的，当多个线程对同一个资源执行操作时，如果不加锁可能会导致最终结果和预期结果不符，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>            i++;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        SynchronizedTest synchronizedTest;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SynTest</span><span class="hljs-params">(SynchronizedTest synchronizedTest)</span> &#123;<br>            <span class="hljs-built_in">this</span>.synchronizedTest = synchronizedTest;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10000</span> ; i++) &#123;<br>                synchronizedTest.add();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SynchronizedTest</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br>        <span class="hljs-comment">// 线程一</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynTest</span>(s)).start();<br>        <span class="hljs-comment">//线程二</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynTest</span>(s)).start();<br>        SleepTools.second(<span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;结果：&quot;</span>+s.i);<br>    &#125;<br>&#125;<br>输出：<br>结果：<span class="hljs-number">18876</span><br></code></pre></td></tr></table></figure><p>输出的结果和预期的20000并不一样，这是因为两个线程同时对该值进行操作，每个线程执行加一操作时需要做两个步骤，首先获取到i的值，然后加一再写到内存；当线程一刚取到值但是还没写，线程二也取值，两个线程都完成加一回写时，实际上这两个线程写的是同一个值。<br>这时候就需要加锁，关键字synchronized 可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p><ol><li>修饰方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>            i++;<br>    &#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>修饰代码块</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">//this指当前实例对象</span><br>            i++;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>修饰成员变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object o=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">synchronized</span> (o) &#123;<br>           i++;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>这个和修饰代码块里的this道理是一样的，都是锁的某个对象。</p><ol start="4"><li>修饰静态方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>            i++;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当synchronized修饰静态方法或静态成员变量时有人说是类锁，实际上锁的虚拟机中该类所对应的class对象，本质上还是类锁。</p><ol start="5"><li><p>面试题<br><strong>对象锁和类锁可以并行运行吗？</strong><br>面试经常回问到这个问题，就如上面所说的，类锁锁的是xxx.class对象，对象锁锁的是‘对象xxx’，锁的不是同一个对象肯定是可以并行的。</p></li><li><p><strong>synchroized错误使用</strong>，如下代码：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadStart</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> Integer i;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable</span><span class="hljs-params">(Integer i)</span> &#123;<br>            <span class="hljs-built_in">this</span>.i = i;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (i) &#123;<br>                Thread thread=Thread.currentThread();<br>                System.out.println(thread.getName()+<span class="hljs-string">&quot;==开始==&quot;</span>+i+<span class="hljs-string">&quot;@&quot;</span>+System.identityHashCode(i));<br>                i++;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(thread.getName()+<span class="hljs-string">&quot;==结束==&quot;</span>+i+<span class="hljs-string">&quot;@&quot;</span>+System.identityHashCode(i)); <span class="hljs-comment">//identityHashCode方法可以理解为内存中的地址</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyRunnable a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">5</span> ; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(a).start();<br>        &#125;<br>    &#125;<br>&#125;<br>输出结果：<br>Thread-<span class="hljs-number">0</span>==开始==<span class="hljs-number">1</span>@<span class="hljs-number">351452368</span><br>Thread-<span class="hljs-number">1</span>==开始==<span class="hljs-number">2</span>@<span class="hljs-number">733316467</span><br>Thread-<span class="hljs-number">2</span>==开始==<span class="hljs-number">3</span>@<span class="hljs-number">696436475</span><br>Thread-<span class="hljs-number">3</span>==开始==<span class="hljs-number">4</span>@<span class="hljs-number">2019092735</span><br>Thread-<span class="hljs-number">1</span>==结束==<span class="hljs-number">5</span>@<span class="hljs-number">628256373</span><br>Thread-<span class="hljs-number">0</span>==结束==<span class="hljs-number">5</span>@<span class="hljs-number">628256373</span><br>Thread-<span class="hljs-number">3</span>==结束==<span class="hljs-number">5</span>@<span class="hljs-number">628256373</span><br>Thread-<span class="hljs-number">4</span>==开始==<span class="hljs-number">5</span>@<span class="hljs-number">628256373</span><br>Thread-<span class="hljs-number">2</span>==结束==<span class="hljs-number">6</span>@<span class="hljs-number">658845115</span><br>Thread-<span class="hljs-number">4</span>==结束==<span class="hljs-number">6</span>@<span class="hljs-number">658845115</span><br></code></pre></td></tr></table></figure><p>按照预期，每个线程都对i进行加一，但实际结果thread-0起始值为1结束值为5，且地址也由351452368变为了628256373。从代码看明显是锁到了i且是同一个对象，为什么会出现这个异常？难道是没锁住？<br>我们把这个类反编译一下，结果如下：<br><img src="https://img-blog.csdnimg.cn/20200423214359565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从反编译的结果我们可以看到，当执行i++的时候实际返回的结果是Integer.valueOf(this.i.intValue() + 1);我们再去Integer类看看这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>    &#125;<br></code></pre></td></tr></table></figure><p>返回的是new Integer对象，那上边的问题就能够讲的通了，当每个线程执行++操作时，i实际都指向了另一个对象，synchroinzed关键字锁的是对象，这里强调的是同一个对象，这段代码当有一个线程返回时这个锁的对象就会发生变化，所有就出现了如上的输出。</p><p><strong>那么这个锁应该怎么加呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadStart</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> Integer i;<br><br>        <span class="hljs-keyword">private</span> Object o=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable</span><span class="hljs-params">(Integer i)</span> &#123;<br>            <span class="hljs-built_in">this</span>.i = i;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (o) &#123;<br>                Thread thread=Thread.currentThread();<br>                System.out.println(thread.getName()+<span class="hljs-string">&quot;==开始==&quot;</span>+i+<span class="hljs-string">&quot;@&quot;</span>+System.identityHashCode(i));<br>                i++;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(thread.getName()+<span class="hljs-string">&quot;==结束==&quot;</span>+i+<span class="hljs-string">&quot;@&quot;</span>+System.identityHashCode(i)); <span class="hljs-comment">//identityHashCode方法可以理解为内存中的地址</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyRunnable a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">5</span> ; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(a).start();<br>        &#125;<br>    &#125;<br>&#125;<br>输出：<br>Thread-<span class="hljs-number">0</span>==开始==<span class="hljs-number">1</span>@<span class="hljs-number">351452368</span><br>Thread-<span class="hljs-number">0</span>==结束==<span class="hljs-number">2</span>@<span class="hljs-number">439697470</span><br>Thread-<span class="hljs-number">4</span>==开始==<span class="hljs-number">2</span>@<span class="hljs-number">439697470</span><br>Thread-<span class="hljs-number">4</span>==结束==<span class="hljs-number">3</span>@<span class="hljs-number">1488227252</span><br>Thread-<span class="hljs-number">3</span>==开始==<span class="hljs-number">3</span>@<span class="hljs-number">1488227252</span><br>Thread-<span class="hljs-number">3</span>==结束==<span class="hljs-number">4</span>@<span class="hljs-number">2019092735</span><br>Thread-<span class="hljs-number">2</span>==开始==<span class="hljs-number">4</span>@<span class="hljs-number">2019092735</span><br>Thread-<span class="hljs-number">2</span>==结束==<span class="hljs-number">5</span>@<span class="hljs-number">696436475</span><br>Thread-<span class="hljs-number">1</span>==开始==<span class="hljs-number">5</span>@<span class="hljs-number">696436475</span><br>Thread-<span class="hljs-number">1</span>==结束==<span class="hljs-number">6</span>@<span class="hljs-number">733316467</span><br></code></pre></td></tr></table></figure><p>我们锁一个不会变化的对象就可以了，检查结果也是符合预期的。</p><h3 id="二、volatile"><a href="#二、volatile" class="headerlink" title="二、volatile"></a>二、volatile</h3><p>volatile是最轻量级的同步机制，一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义</p><ol><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。</li></ol><p>第一条比较好理解，主要是理解第二条，指令重排序的定义如下：</p><blockquote><p>为了尽可能减少内存操作速度远慢于CPU运行速度所带来的CPU空置的影响，虚拟机会按照自己的一些规则将程序编写顺序打乱——即写在后面的代码在时间顺序上可能会先执行，而写在前面的代码会后执行——以尽可能充分地利用CPU，但最终的执行结果不变。</p></blockquote><p>volatile只是保证可见性，即只是保证读一直性并不保证写只能有一个线程写，如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">VolatileTest</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-built_in">this</span>.i = i;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        VolatileTest volatileTest;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable</span><span class="hljs-params">(VolatileTest volatileTest)</span> &#123;<br>            <span class="hljs-built_in">this</span>.volatileTest = volatileTest;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10000</span> ; i++) &#123;<br>                volatileTest.add();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        VolatileTest v=<span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileTest</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(v)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(v)).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;i=&quot;</span>+v.i);<br>    &#125;<br>&#125;<br>输出：<br>i=<span class="hljs-number">19695</span><br></code></pre></td></tr></table></figure><p>所以，volatile关键字适合一写多读的场景。</p><h3 id="三、ThreadLocal"><a href="#三、ThreadLocal" class="headerlink" title="三、ThreadLocal"></a>三、ThreadLocal</h3><p>ThreadLocal类的作用是在多线程编程下，保证线程间数据的隔离，实现的方法就是为每个线程维护一个变量的副本。<br><strong>1. ThreadLocal使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Integer&gt; age=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Integer&gt;()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;;<br><br><span class="hljs-comment">//    private static int age=1;</span><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>            <span class="hljs-built_in">this</span>.number = number;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            Thread thread=Thread.currentThread();<br>            System.out.println(thread.getName()+<span class="hljs-string">&quot;==start==&quot;</span>+age.get());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><span class="hljs-comment">//            number=age.get()+number;</span><br>            age.set(number+age.get());<br><br>            System.out.println(thread.getName()+<span class="hljs-string">&quot;==end==&quot;</span>+age.get());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ThreadLocalTest threadLocalTest=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalTest</span>();<br><br>        Thread[] threads=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">3</span> ; i++) &#123;<br>            threads[i]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(i));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>            thread.start();<br>        &#125;<br>    &#125;<br>&#125;<br>输出：<br>Thread-<span class="hljs-number">0</span>==start==<span class="hljs-number">1</span><br>Thread-<span class="hljs-number">2</span>==start==<span class="hljs-number">1</span><br>Thread-<span class="hljs-number">1</span>==start==<span class="hljs-number">1</span><br>Thread-<span class="hljs-number">1</span>==end==<span class="hljs-number">2</span><br>Thread-<span class="hljs-number">0</span>==end==<span class="hljs-number">1</span><br>Thread-<span class="hljs-number">2</span>==end==<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>2. ThreadLocal的实现解析</strong><br><img src="https://img-blog.csdnimg.cn/20200424144134690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>声明一个ThreadLocal类型的属性，每个线程都会维护自己的一个ThreadLocalMap属性，查看Thread原密会发现这个属性<img src="https://img-blog.csdnimg.cn/20200424144340140.png" alt="在这里插入图片描述"><br>可看到该属性是专门为ThreadLocal设计的，而ThreadLocalMap又是ThreadLocal的内部类，查看ThreadLocal源码：<img src="https://img-blog.csdnimg.cn/2020042414455461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到有个 Entry 内部静态类，它继承了 WeakReference，总之它记录了两个信息，一个是 ThreadLocal&lt;?&gt;类型，一个是 Object 类型的值。getEntry 方法则是获取某个 ThreadLocal 对应的值，set 方法就是更新或赋值相应的 ThreadLocal<br>对应的值。<br>ThreadLocal的值获取流程就是，先获取当前线程的ThreadLocalMap属性，然后根据当前ThreadLocal的实例获取map中的Entry对象，即获取了值。</p><p><strong>3. ThreadLocal使用不当可能造成内存溢出</strong><br>先看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalOOMl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TASK_MAX_LOOP=<span class="hljs-number">500</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadPoolExecutor threadPoolExecutor=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<br>            TimeUnit.MINUTES,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;());<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariable</span>(); <span class="hljs-comment">//执行创建数组</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalVariable</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">5</span>]; <span class="hljs-comment">//创建一个5M的数组</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;TASK_MAX_LOOP ; i++) &#123;<br>            threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalOOMl</span>());<br>            System.out.println(<span class="hljs-string">&quot;not use threadLocal!&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;thread excute over!&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用jdk自带的jvm监控工具（位置在bin&#x2F;jvisualvm.exe），查看堆的使用大小如下：<br><img src="https://img-blog.csdnimg.cn/20200424185246548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们线程池的大小是5，也就是最多5个线程同时运行，占用的堆内存基本维持在25M以下这是正常的。有人可能会问每个线程new一个5M的数组为什么只有25M？看下代码new ThreadLocalOOMl()，我们每次只是在堆上new了一个对象，该对象并没有被引用，所以该对象会被回收，所以堆的内存大概只有25M。</p><p>使用ThreadLocal代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalOOMl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TASK_MAX_LOOP=<span class="hljs-number">500</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadPoolExecutor threadPoolExecutor=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<br>            TimeUnit.MINUTES,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;());<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;LocalVariable&gt; localVariable=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        localVariable.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariable</span>()); <span class="hljs-comment">//每个线程维护一个threadLocal副本</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalVariable</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">5</span>]; <span class="hljs-comment">//创建一个5M的数组</span><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;TASK_MAX_LOOP ; i++) &#123;<br>            threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalOOMl</span>());<br>            System.out.println(<span class="hljs-string">&quot;use threadLocal!&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;thread excute over!&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200424190850316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们的预期结果应该是和不使用threadLocal一致大概25M左右，实际上最高已经来到250左右，出现了内存溢出。这是为什么呢？接下来分析</p><p>分析之前先说以下java里的几种引用：</p><ol><li>强引用<br>就是指在程序代码之中普遍存在的，类似“Object obj&#x3D;new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象实例。</li><li>软引用<br>用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象实例列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK1.2 之后，提供了 SoftReference 类来实现软引用。</li><li>弱引用<br>用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象实例只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象实例。在 JDK 1.2 之后，提供了WeakReference 类来实现弱引用。</li><li>虚引用也称为幽灵引用或者幻影引用<br>它是最弱的一种引用关系。一个对象实例是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象实例被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了PhantomReference 类来实现虚引用。</li></ol><p>再来梳理以下ThreadLocal这个类，每个线程维护了一个ThreadLocalMap对象，它的key是ThreadLocal对象，值是Entry数组，真正存储数据的是Enter，<br>查看源码我们会发现Entry对ThreadLocal引用是弱引用<br><img src="https://img-blog.csdnimg.cn/20200424192244326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>前边说过当发生内存回收的时候，ThreadLocal会被回收，所有使用ThreadLocal后整个调用关系可用如下图描述：<br><img src="https://img-blog.csdnimg.cn/20200424192505955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当发生内存回收时，ThradLocal对象被回收，此时该对象所对应的Entry的value将会永远不会被访问，而Entry对该值是强引用，所以该value无法被回收这就造成了内存泄露。除非当线程结束时，下方的调用链就是被回收，但是我们这里使用了线程池，线程不会结束。。。那么怎么办呢？<br>其实只要在你使用完这个值，主动把这个值释放掉就可以了，代码修改比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>      localVariable.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariable</span>()); <span class="hljs-comment">//每个线程维护一个threadLocal副本</span><br>      System.out.println(<span class="hljs-string">&quot;我获取到了值，可以释放了...&quot;</span>);<br>      localVariable.remove();<br>  &#125;<br></code></pre></td></tr></table></figure><p>使用完调用remove()方法，就会释放该值，可以查看remove的源码，发现最终会调到expungeStaleEntry()释放没用的Entry。查看堆的大小就正常了<br><img src="https://img-blog.csdnimg.cn/20200424193506308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0ODYzNzQz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>所以，在使用线程池和ThreadLocal的时候要注意这个问题，在使用完值后一定要记得释放。</strong></p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>synchronized解决了多线程编程下的数据共享问题，而ThreadLocal则是实现了线程间的隔离。但如果使用的不好也能造成其他的问题，一定要牢记。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java并发编程-线程基础</title>
    <link href="/2022/06/26/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/06/26/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="1-进程与线程的区别"><a href="#1-进程与线程的区别" class="headerlink" title="1.进程与线程的区别"></a>1.进程与线程的区别</h3><ol><li><strong>进程是程序运行资源分配的最小单位</strong>，也就是说操作系统封是以进程为单位进行分配资源的，资源包括cpu时间片、内存、磁盘io等；进程与进程之间是相互独立的，一个应用程序可以理解为一个进程，当你打开微信又打开支付宝的时候这两个应用都可以正常工作，所以说进程之间的独立的。进程又可以分为系统进程和用户进程，比如当你按下电脑卡机键，你就可以打开桌面，这是系统启动的进程；而你打开浏览器，这是你自己启动的进程，就是用户进程。</li><li><strong>线程是cpu调度的最小单位</strong>，线程必须依赖于进程存在，一个进程内可以有线程，所有线程共享进程的资源，线程负责执行进程的各个功能，线程本身占用很少的资源（如程序计数器）</li></ol><h3 id="2-java中有几种新启线程方式"><a href="#2-java中有几种新启线程方式" class="headerlink" title="2.java中有几种新启线程方式"></a>2.java中有几种新启线程方式</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于这个问题大多数人可能会想到3种，继承Thread、实现Runnable接口、实现Callable接口，其实java的官方给出的答案是2种，它认为实现Runnable接口、实现Callable接口是一种方式。</p><blockquote><p><strong>There are two ways to create a new thread of execution.–Thread类第73行注释</strong></p></blockquote><p>两种启动线程的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadStart</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;myThread start....&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;myRunnable start...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyThread a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        a.start();<br><br>        MyRunnable b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(b).start();<br>    &#125;<br><br>输出：<br>myThread start....<br>myRunnable start...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-对于start-方法和run-方法的理解"><a href="#3-对于start-方法和run-方法的理解" class="headerlink" title="3.对于start()方法和run()方法的理解"></a>3.对于start()方法和run()方法的理解</h3><ol><li><pre><code class="hljs">run()方法和线程的启动与否没有关系，它是具体执行业务逻辑的功能，就是一个成员方法，实例化类后可以直接调用。如下代码可以证明：</code></pre></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadStart</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;myRunnable start...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        MyRunnable b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        b.run();<br>    &#125;<br><br>&#125;<br>输出<br>myRunnable start...<br></code></pre></td></tr></table></figure><ol start="2"><li>start()方法是真正创建线程的方法，查看源码会发现它调用的start0()方法，该方法的定义*private native void start0();*实际上这个方法调用的jvm里由C语言写的方法去调操作系统的api完成线程的创建。</li></ol><h3 id="4-如何让线程安全停止"><a href="#4-如何让线程安全停止" class="headerlink" title="4.如何让线程安全停止"></a>4.如何让线程安全停止</h3><ol><li><p><strong>线程停止的方式</strong></p><ul><li>执行完run()方法，程序自然结束</li></ul><ul><li>程序抛出未处理的异常，导致终止</li></ul></li><li><p><strong>线程的暂停、恢复和停止操作（不安全）</strong></p><p> 线程的暂停、恢复和停止操作对应的API分别为<del>suspend()</del> 、<del>resume()</del> 、<del>stop</del> 。查看源码发现这些方法已经都被标注为过期不建议使用，因为这些方法都比较野蛮，不会给线程释放资源的时间，如果线程持有锁可能会导致死锁的出现。</p></li><li><p><strong>如何安全的终止线程</strong><br>  <strong>interrupt()方法</strong></p></li></ol><p>  Thread提供了interrupt()方法，该方法的作用是另启动一个线程给当前线程打标签（标签的值有ture和false两）；因为java中的线程是协作式的并非抢占式的，所以线程被打上中断的标签后可以不做理会。如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            String threadName=Thread.currentThread().getName();<br>            System.out.println(threadName+<span class="hljs-string">&quot; interrupt flag: &quot;</span>+isInterrupted());<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.out.println(threadName+<span class="hljs-string">&quot; is running&quot;</span>);<br>                System.out.println(threadName+<span class="hljs-string">&quot; interrupt flag: &quot;</span>+isInterrupted());<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        MyThread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        thread.interrupt();<br>    &#125;<br>&#125;<br>输出（截取一部分）：<br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">true</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">true</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>根据输出结果可以看到，即使调用了interrupt()方法，线程依然可以继续执行。</p><p><strong>监控标签值控制程序执行</strong><br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;例如我在判断标签值之前就释放该线程的所占有的锁或者资源，这样即使线程中断也不会再持有锁和资源，不会发生死锁的情况也不会造成资源的浪费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            String threadName=Thread.currentThread().getName();<br>            System.out.println(threadName+<span class="hljs-string">&quot; interrupt flag: &quot;</span>+isInterrupted());<br><span class="hljs-comment">//            while (true) &#123;</span><br>            <span class="hljs-keyword">while</span> (!isInterrupted()) &#123;<br>                System.out.println(threadName+<span class="hljs-string">&quot; is running&quot;</span>);<br>                System.out.println(threadName+<span class="hljs-string">&quot; inner interrupt flag: &quot;</span>+isInterrupted());<br>            &#125;<br>            System.out.println(threadName+<span class="hljs-string">&quot; interrupt flag: &quot;</span>+isInterrupted());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        MyThread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">3</span>);<br>        thread.interrupt();<br>    &#125;<br><br>输出：<br>......<br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> inner interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> inner interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> inner interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> inner interrupt flag: <span class="hljs-literal">true</span><br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">true</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>isInterrupted()和Thread.interrupted的区别</strong></p><p>前者只是返回标志位的值，后者也是返回标志位的值并且把标志位的值改为false，如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterruptTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            String threadName=Thread.currentThread().getName();<br>            System.out.println(threadName+<span class="hljs-string">&quot; interrupt flag: &quot;</span>+isInterrupted());<br><span class="hljs-comment">//            while (true) &#123;</span><br><span class="hljs-comment">//            while (!isInterrupted()) &#123;</span><br>            <span class="hljs-keyword">while</span> (!interrupted()) &#123;<br>                System.out.println(threadName+<span class="hljs-string">&quot; is running&quot;</span>);<br>                System.out.println(threadName+<span class="hljs-string">&quot; inner interrupt flag: &quot;</span>+isInterrupted());<br>            &#125;<br>            System.out.println(threadName+<span class="hljs-string">&quot; interrupt flag: &quot;</span>+isInterrupted());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        MyThread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">3</span>);<br>        thread.interrupt();<br>    &#125;<br>&#125;<br>输出：<br>......<br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> inner interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> inner interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> is running<br>Thread-<span class="hljs-number">0</span> inner interrupt flag: <span class="hljs-literal">false</span><br>Thread-<span class="hljs-number">0</span> interrupt flag: <span class="hljs-literal">false</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="5-yield-、priority-和join-方法"><a href="#5-yield-、priority-和join-方法" class="headerlink" title="5.yield()、priority()和join()方法"></a>5.yield()、priority()和join()方法</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;为什么会把这几个方法放到一起说，因为面试的时候经常会围绕这几个方法问一些线程执行顺序的问题。<br><strong>1. yield方法</strong><br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;yield方法是让出当前线程的cpu时间片，使线程由运行状态变为就绪状态。注意这里并不会释放资源，让出的时间也是不可以指定的。<strong>就绪状态的线程都有可能被cpu选择</strong>，举个例子：皇上有三个妃子A、B、C在等着侍寝，皇上叫A进去侍寝，中途A想到和BC共苦的日子不容易，所以就想着共同致富，于是A说自己要上厕所就出去了，但是皇上不乐意了，我乃九五至尊岂容你撒野，于是又把A叫进去了，A接着侍寝……<br><strong>2. setPriority方法</strong><br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;priority方法是设置线程执行的优先级，根据字面理解可能会误认为优先级高的一定会在优先级低的线程之前执行，实际上不是这样的，优先级高只不过是被cpu选择的概率会大一点。验证代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YieldTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">super</span>(name);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 开始运行...&quot;</span>+i);<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">600</span>) &#123;<br>                    yield();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程一&quot;</span>);<br>        a.setPriority(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程二&quot;</span>);<br>        b.setPriority(<span class="hljs-number">10</span>);<br>        a.start();<br>        b.start();<br>    &#125;<br>&#125;<br>输出：<br>...<br>线程二 开始运行..<span class="hljs-number">.600</span><br>线程一 开始运行..<span class="hljs-number">.17</span><br>线程一 开始运行..<span class="hljs-number">.18</span><br>线程二 开始运行..<span class="hljs-number">.601</span><br>...<br>线程二 开始运行..<span class="hljs-number">.834</span><br>线程一 开始运行..<span class="hljs-number">.19</span><br>线程二 开始运行..<span class="hljs-number">.835</span><br></code></pre></td></tr></table></figure><p>从代码的输出结果看，线程二的优先级高确实执行的比较快以为被cpu选择的概率大，但cpu并不是100%选择线程二，也会选择线程一执行。所以这就验证上述结论是正确的。<br><strong>3. join方法</strong><br>join()方法是将交替执行的线程设置为顺序执行，比如在A线程中调用B的join方法，则A会等B执行完再继续执行。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Goddless</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-keyword">private</span> Thread thread;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Goddless</span><span class="hljs-params">(Thread thread)</span> &#123;<br>            <span class="hljs-built_in">this</span>.thread = thread;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;goddless 开始打饭...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>) &#123;<br>                    thread.join();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>            SleepTools.second(<span class="hljs-number">2</span>);<br>            System.out.println(<span class="hljs-string">&quot;goddles 打饭结束...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GoddlessBoyFriend</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;goddless boyfirend 开始打饭...&quot;</span>);<br>            SleepTools.second(<span class="hljs-number">2</span>);<br>            System.out.println(<span class="hljs-string">&quot;goddless boyfriend 打饭结束...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread current=Thread.currentThread();<br><br>        Thread gbf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">GoddlessBoyFriend</span>();<br><br>        Goddless goddless=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Goddless</span>(gbf);<br>        Thread g=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(goddless);<br>        g.start();<br>        gbf.start();<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 你开始打饭...&quot;</span>);<br>        g.join();<br>        SleepTools.second(<span class="hljs-number">2</span>);<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 你打饭结束...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>程序执行流程：<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;你正在打饭刚好看见女神来打饭，你让女神插队排在你的前面，正当你狡猾的露出笑容时女神看到的男朋友并让他排在女神前边打饭，女神男朋友打完饭接着女神打饭女神也打完饭两人手牵手走到了唯一的一个空座位坐下有说有笑的开始吃饭。终于轮到了你打饭，阿姨说就剩半个馒头拿走送你了…</p></blockquote><h3 id="6-守护线程"><a href="#6-守护线程" class="headerlink" title="6.守护线程"></a>6.守护线程</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调 度以及支持性工作。这意味着，当一个 Java 虚拟机中不存在非 Daemon 线程的 时候，Java 虚拟机将会退出。可以通过调用 Thread.setDaemon(true)将线程设置 为 Daemon 线程。我们一般用不上，比如垃圾回收线程就是 Daemon 线程。<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Daemon 线程被用作完成支持性工作，但是在 Java 虚拟机退出时 Daemon 线 程中的 finally 块并不一定会执行。在构建 Daemon 线程时，不能依靠 finally 块中 的内容来确保执行关闭或清理资源的逻辑。 </p><h3 id="7-写给自己"><a href="#7-写给自己" class="headerlink" title="7.写给自己"></a>7.写给自己</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我是一个菜鸟，这是我写的第一篇博客大概用了5个小时，从现在开始我会用博客记录自己学到的知识，也希望自己能够坚持下来，记录自己的成长。努力是为了给自己更多的选择！加油！</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法介绍</title>
    <link href="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="排序算法概述"><a href="#排序算法概述" class="headerlink" title="排序算法概述"></a>排序算法概述</h3><p>排序是将一组对象按照某种逻辑顺序重新排列过程。比如，订单按照日期排序，这种排序很可能使用了某种排序算法。现在计算机的使用很广泛，随之差生的数据无处不在，而整理数据的第一步通常就是排序。</p><p>十大排序算法：冒泡排序、选择排序、插入排序、归并排序、堆排序、快速排序、希尔排序、计数排序、基数排序、桶排序</p><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><p>一种简单的排序算法。它反复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。这个工作重复地进行直到没有元素再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为元素会经由交换慢慢“浮”到数列的顶端。 </p><p><strong>操作步骤</strong></p><ol><li>从数组头开始，比较相邻的元素。如果第一个比第二个大(小)，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到尾部的最后一对，这样在最后的元素应该会是最大(小)的数；</li><li>重复步骤1~2，重复次数等于数组的长度，直到排序完成。</li></ol><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" class="" title="冒泡排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array) &#123;<br><br>    <span class="hljs-keyword">if</span> (array.length&lt;<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (array[j]&gt;array[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-type">int</span> temp=array[j+<span class="hljs-number">1</span>];<br>                array[j+<span class="hljs-number">1</span>]=array[j];<br>                array[j]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><p><strong>操作步骤</strong></p><ol><li>首先，找到数组中最大（小）的那个元素</li><li>其次，将它和数组的第一个元素交换位置（如果第一个元素就是最大（小）元素那么它就和自己交换）</li><li>再次，在剩下的元素中找到最大（小）的元素，将它与数组的第二个元素交换位置</li><li>如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最大（小）者</li></ol><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" class="" title="选择排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array)&#123;<br><br>    <span class="hljs-keyword">if</span> (array.length&lt;<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        <span class="hljs-type">int</span> min=i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; array.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (array[j]&lt;array[min]) &#123;<br>                min=j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> temp=array[i];<br>        array[i]=array[min];<br>        array[min]=temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><p>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。为了给要插入的元素腾出空间，我们需要将插入位置之后的已排序元素在都向后移动一位。插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快得多。总的来说，插入排序对于部分有序的数组十分高效，也很适合小规模数组</p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" class="" title="插入排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array) &#123;<br>    <span class="hljs-keyword">if</span> (array.length&lt;<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        <span class="hljs-type">int</span> currentValue=array[i];<br>        <span class="hljs-type">int</span> preIndex=i-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; array[preIndex] &gt; currentValue) &#123;<br>            array[preIndex+<span class="hljs-number">1</span>]=array[preIndex];<br>            preIndex--;<br>        &#125;<br>        array[preIndex+<span class="hljs-number">1</span>]=currentValue;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h3><p>一种基于<strong>插入排序</strong>的快速的排序算法。简单插入排序对于大规模乱序数组很慢，因为元素只能一点一点地从数组的一端移动到另一端。例如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需要N-1 次移动。</p><p>希尔排序为了加快速度简单地改进了插入排序，也称为缩小增量排序，同时该算法是突破O(n^2）的第一批算法之一。</p><p>希尔排序是把待排序数组按一定数量的分组，对每组使用直接插入排序算法排序；然后缩小数量继续分组排序，随着数量逐渐减少，每组包含的元素越来越多，当数量减至 1 时，整个数组恰被分成一组，排序便完成了。这个不断缩小的数量，就构成了一个增量序列。</p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" class="" title="希尔排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array)&#123;<br><br>    <span class="hljs-type">int</span> len=array.length;<br>    <span class="hljs-comment">// 确定分组步长，逐渐减小直至未1，此时整个数组排序完成</span><br>    <span class="hljs-type">int</span> gap=len/<span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">while</span> (gap&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=gap;i&lt;len;i++)&#123; <span class="hljs-comment">//当前元素与组内已有元素对比</span><br>            <span class="hljs-type">int</span> currentValue=array[i];<br>            <span class="hljs-type">int</span> preIndex=i-gap; <span class="hljs-comment">//组内的前一个元素索引</span><br>            <span class="hljs-keyword">while</span> (preIndex&gt;=<span class="hljs-number">0</span> &amp;&amp; array[preIndex]&gt;currentValue)&#123;<br>                array[preIndex+gap]=array[preIndex];<br>                preIndex=preIndex-gap;<br>            &#125;<br>            array[preIndex+gap]=currentValue;<br>        &#125;<br>        gap=gap/<span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。对于给定的一组数据，利用递归与分治技术将数据序列划分成为越来越小的半子表，在对半子表排序后，再用递归方法将排好序的半子表合并成为越来越大的有序序列。为了提升性能，有时我们在半子表的个数小于某个数（比如15）的情况下，对半子表的排序采用其他排序算法，比如插入排序。若将两个有序表合并成一个有序表，称为2-路归并，与之对应的还有多路归并。</p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" class="" title="归并排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array) &#123;<br>    <span class="hljs-keyword">if</span> (array.length &lt; <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">//只有一个元素的时候说明已是最小粒度，开始合并</span><br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> array.length / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span>[] left = Arrays.copyOfRange(array, <span class="hljs-number">0</span>, mid);<br>    <span class="hljs-type">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);<br>    <span class="hljs-keyword">return</span> merge(sort(left), sort(right));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] merge(<span class="hljs-type">int</span>[] left, <span class="hljs-type">int</span>[] right) &#123;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[left.length + right.length];<br>    <span class="hljs-type">int</span> index, leftIndex, rightIndex;<br>    <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>, leftIndex = <span class="hljs-number">0</span>, rightIndex = <span class="hljs-number">0</span>; index &lt; result.length; index++) &#123;<br>        <span class="hljs-keyword">if</span> (leftIndex &gt;= left.length) &#123; <span class="hljs-comment">//如果左边已经全排完，右队列依次填入结果</span><br>            result[index] = right[rightIndex++];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightIndex &gt;= right.length) &#123;<span class="hljs-comment">//如果右边已经全排完，左队列依次填入结果</span><br>            result[index] = left[leftIndex++];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left[leftIndex] &gt; right[rightIndex]) &#123;<br>            result[index] = right[rightIndex++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result[index] = left[leftIndex++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6.快速排序"></a>6.快速排序</h3><p>快速排序（Quicksort）是对冒泡排序的一种改进，也是采用分治法的一个典型的应用。首先任意选取一个数据（比如数组的第一个数）作为关键数据，我们称为基准数(Pivot)，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序，也称为分区（partition）操作。通过一趟快速排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数组变成有序序列。为了提升性能，有时我们在分割后独立的两部分的个数小于某个数（比如15）的情况下，会采用其他排序算法，比如插入排序。</p><p><strong>基准的选取</strong>：最优的情况是基准值刚好取在无序区数值的中位数，这样能够最大效率地让两边排序，同时最大地减少递归划分的次数，但是一般很难做到最优。基准的选取一般有三种方式，选取数组的第一个元素，选取数组的最后一个元素，以及选取第一个、最后一个以及中间的元素的中位数（如4 5 6 7, 第一个4, 最后一个7, 中间的为5, 这三个数的中位数为５, 所以选择5作为基准）。Dual-Pivot快排：双基准快速排序算法，其实就是用两个基准数, 把整个数组分成三份来进行快速排序，在这种新的算法下面，比经典快排从实验来看节省了10%的时间。</p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" class="" title="快速排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end) &#123;<br>    <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span> || end &lt; <span class="hljs-number">0</span> || start &gt; end || array.length &lt; <span class="hljs-number">1</span> || end &gt;= array.length || start&gt;=array.length) &#123; <span class="hljs-comment">//数组为1结束</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> array[end]; <span class="hljs-comment">//取最后一个元素为基数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">zoneIndex</span> <span class="hljs-operator">=</span> start - <span class="hljs-number">1</span>; <span class="hljs-comment">//分区指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>        <span class="hljs-keyword">if</span> (array[i] &lt;= pivot) &#123;<br>            zoneIndex++;<br>            <span class="hljs-keyword">if</span> (i &gt; zoneIndex) &#123;<br>                swap(array, i, zoneIndex);<br>            &#125;<br>        &#125;<br>    &#125;<br>   <br>    <span class="hljs-keyword">if</span> (zoneIndex &gt; start) &#123;<br>        sort(array, start, zoneIndex - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (zoneIndex &lt; end) &#123;<br>        sort(array, zoneIndex + <span class="hljs-number">1</span>, end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[to];<br>    array[to] = array[from];<br>    array[from] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h3><p>许多应用程序都需要处理有序的元素，但不一定要求他们全部有序，或者不一定要一次就将他们排序，很多时候，我们每次只需要操作数据中的最大元素（最小元素），那么有一种基于二叉堆的数据结构可以提供支持。所谓二叉堆，是一个完全二叉树的结构，同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。在一个二叉堆中，根节点总是最大（或者最小）节点。堆排序算法就是抓住了这一特点，每次都取堆顶的元素，然后将剩余的元素重新调整为最大（最小）堆，依次类推，最终得到排序的序列。</p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E4%BA%8C%E5%8F%89%E6%A0%91.png" class="" title="二叉树"><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%A0%86%E6%8E%92%E5%BA%8F.png" class="" title="堆排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> len;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array) &#123;<br>    len = array.length;<br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>    buildMaxHeap(array);<br><br>    <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">1</span>) &#123;<br>        swap(array, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>        len--;<br>        adjustHeap(array, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        adjustHeap(array, i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxIndex</span> <span class="hljs-operator">=</span> i;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * (i + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (left &lt; len &amp;&amp; array[left] &gt; array[maxIndex]) &#123;<br>        maxIndex = left;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (right &lt; len &amp;&amp; array[right] &gt; array[maxIndex]) &#123;<br>        maxIndex = right;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (maxIndex != i) &#123;<br>        swap(array, maxIndex, i);<br>        adjustHeap(array, maxIndex);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[to];<br>    array[to] = array[from];<br>    array[from] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h3><p>计数排序对一定范围内的整数排序时候的速度非常快，一般快于其他排序算法。但计数排序局限性比较大，只限于对整数进行排序，而且待排序元素值分布较连续、跨度小的情况。计数排序是一个排序时不比较元素大小的排序算法。如果一个数组里所有元素都是整数，而且都在0-K以内。对于数组里每个元素来说，如果能知道数组里有多少项小于或等于该元素，就能准确地给出该元素在排序后的数组的位置。</p><p>实际应用中我们会同时找出数组中的max和min，主要是为了尽量节省空间。试想[1003, 1001, 1030, 1050]这样的数据要排序，真的需要建立长度为1050 + 1的数组吗？我们只需要长度为1050 - 1003 + 1&#x3D; 48的数组（先不考虑额外+1的长度），就能囊括从最小到最大元素之间的所有元素了。如果待排序数组的元素值跨度很大，比如[99999, 1, 2]，为三个元素排序要使用99999 - 1 + 1的空间，实在是浪费。<strong>所以计数排序适用于待排序元素值分布较连续、跨度小的情况。</strong></p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.png" class="" title="计数排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array)&#123;<br>    <span class="hljs-type">int</span> len=array.length;<br>    <span class="hljs-keyword">if</span> (len&lt;<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-type">int</span> min=array[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> max=array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (array[i]&gt;max)&#123;<br>            max=array[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (array[i]&lt;min)&#123;<br>            min=array[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> bias=<span class="hljs-number">0</span>-min; <span class="hljs-comment">//偏移量，为了把原始数组中最小值映射到计数数组的0起始位置</span><br>    <span class="hljs-type">int</span>[] countArray=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max-min+<span class="hljs-number">1</span>];<br>    Arrays.fill(countArray,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//遍历数组，将原始数组元素映射到计数数组的下标位置，并计数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        countArray[bias+array[i]]++;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;计数数组为：&quot;</span>);<br>    PrintArray.print(countArray);<br><br>    <span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>; <span class="hljs-comment">//原始数组的起始位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; countArray.length; i++) &#123;<br>        <span class="hljs-keyword">while</span> (countArray[i]&gt;<span class="hljs-number">0</span>)&#123;<br>            countArray[i]--;<br>            array[pos]=i-bias;<br>            pos++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9.桶排序"></a>9.桶排序</h3><p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，利用某种函数的映射关系将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序）。 </p><p>桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做排序即可。</p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E6%A1%B6%E6%8E%92%E5%BA%8F.png" class="" title="桶排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketSort</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array      待排序数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketSize 桶容量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; <span class="hljs-title function_">sort</span><span class="hljs-params">(ArrayList&lt;Integer&gt; array, <span class="hljs-type">int</span> bucketSize)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;arraySize:&quot;</span>+array.size()+<span class="hljs-string">&quot;, bucketSize:&quot;</span>+bucketSize);<br>        <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.size() &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> array;<br>        &#125;<br><br>        <span class="hljs-type">int</span> len=array.size();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> array.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> array.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (array.get(i) &gt; max) &#123;<br>                max = array.get(i);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (array.get(i) &lt; min) &#123;<br>                min = array.get(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*初始化桶容器*/</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bucketCount</span> <span class="hljs-operator">=</span> (max - min) / bucketSize + <span class="hljs-number">1</span>;<br>        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(bucketCount); <span class="hljs-comment">//初始化桶个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>            bucketArr.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        &#125;<br><br>        <span class="hljs-comment">/*数据放入每个桶中*/</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));<br>        &#125;<br><br>        <span class="hljs-comment">/*查看桶中数据存放情况*/</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketArr.size(); i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;第【&quot;</span>+i+<span class="hljs-string">&quot;】个桶中的元素是：&quot;</span>);<br>            ArrayList&lt;Integer&gt; list=bucketArr.get(i);<br>            Iterator&lt;Integer&gt; iterator=list.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>                System.out.print(iterator.next()+<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br><br>        ArrayList&lt;Integer&gt; resultArr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketArr.size(); i++) &#123;<br>            ArrayList&lt;Integer&gt; list=bucketArr.get(i);<br>            <span class="hljs-keyword">if</span> (list.size()&gt;<span class="hljs-number">1</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;第【&quot;</span>+i+<span class="hljs-string">&quot;]个桶元素需要重新排序&quot;</span>);<br>                list=sort(list,bucketSize/<span class="hljs-number">2</span>);<br>            &#125;<br>            Iterator&lt;Integer&gt; iterator=list.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>                resultArr.add(iterator.next());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resultArr;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        Integer[] array=&#123;4,6,8,9,2,17,25&#125;;</span><br>        ArrayList&lt;Integer&gt; SRC=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        SRC.add(<span class="hljs-number">4</span>);<br>        SRC.add(<span class="hljs-number">9</span>);<br>        SRC.add(<span class="hljs-number">17</span>);<br>        SRC.add(<span class="hljs-number">8</span>);<br>        SRC.add(<span class="hljs-number">6</span>);<br>        SRC.add(<span class="hljs-number">25</span>);<br>        SRC.add(<span class="hljs-number">2</span>);<br>        PrintArray.print(SRC);<br>        System.out.println(<span class="hljs-string">&quot;======================================&quot;</span>);<br>        ArrayList&lt;Integer&gt; res= BucketSort.sort(SRC,<span class="hljs-number">4</span>);<br>        PrintArray.print(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h3><p>常见的数据元素一般是由若干位组成的，比如字符串由若干字符组成，整数由若干位0<del>9数字组成。基数排序按照从右往左的顺序，依次将每一位都当做一次关键字，然后按照该关键字对数组排序，同时每一轮排序都基于上轮排序后的结果；当我们将所有的位排序后，整个数组就达到有序状态。基数排序不是基于比较的算法。基数是什么意思？对于十进制整数，每一位都只可能是0</del>9中的某一个，总共10种可能。那10就是它的基，同理二进制数字的基为2；对于字符串，如果它使用的是8位的扩展ASCII字符集，那么它的基就是256</p><p><strong>图示</strong></p><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png" class="" title="基数排序"><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 整数排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RadixSortInt</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] array) &#123;<br>        <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span> || array.length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> array;<br>        &#125;<br>        <span class="hljs-comment">/*找出最大数*/</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; array.length; i++) &#123;<br>            max = Math.max(max, array[i]);<br>        &#125;<br><br>        <span class="hljs-comment">/*先算出最大数的位数*/</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDigit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>            max /= <span class="hljs-number">10</span>;<br>            maxDigit++;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, div = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/*构建桶*/</span><br>        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            bucketList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        &#125;<br>        <span class="hljs-comment">/*按照从右往左的顺序，依次将每一位都当做一次关键字，然后按照该关键字对数组排序，</span><br><span class="hljs-comment">        每一轮排序都基于上轮排序后的结果*/</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maxDigit; i++, mod *= <span class="hljs-number">10</span>, div *= <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-comment">/*遍历原始数组，投入桶中*/</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (array[j] % mod) / div;<br>                bucketList.get(num).add(array[j]);<br>            &#125;<br>            <span class="hljs-comment">/*桶中的数据写回原始数组，清除桶，准备下一轮的排序*/</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; bucketList.size(); j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; bucketList.get(j).size(); k++) &#123;<br>                    array[index++] = bucketList.get(j).get(k);<br>                &#125;<br>                bucketList.get(j).clear();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span>[] SRC = &#123;<span class="hljs-number">86</span>, <span class="hljs-number">11</span>, <span class="hljs-number">77</span>, <span class="hljs-number">22</span>, <span class="hljs-number">32</span>, <span class="hljs-number">45</span>, <span class="hljs-number">58</span>, <span class="hljs-number">63</span>, <span class="hljs-number">93</span>, <span class="hljs-number">4</span>, <span class="hljs-number">37</span>, <span class="hljs-number">23</span>&#125;;<br>        PrintArray.print(SRC);<br>        System.out.println(<span class="hljs-string">&quot;============================================&quot;</span>);<br>        <span class="hljs-type">int</span>[] dest = RadixSortInt.sort(PrintArray.SRC);<br>        PrintArray.print(dest);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符串排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RadixSortString</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  ArrayList&lt;String&gt; <span class="hljs-title function_">sort</span><span class="hljs-params">(ArrayList&lt;String&gt; arrayList)</span>&#123;<br>        <span class="hljs-keyword">if</span> (arrayList==<span class="hljs-literal">null</span> || arrayList.size()&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> arrayList;<br>        &#125;<br><br>        <span class="hljs-comment">/*获取最大长度字符串，决定需要遍历几次*/</span><br>        <span class="hljs-type">int</span> maxLen=arrayList.get(<span class="hljs-number">0</span>).length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrayList.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (arrayList.get(i).length()&gt;maxLen)&#123;<br>                maxLen=arrayList.get(i).length();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/*初始化桶*/</span><br>        ArrayList&lt;ArrayList&lt;String&gt;&gt; bucketArr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">128</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++) &#123;<br>            bucketArr.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;());<br>        &#125;<br><br>        <span class="hljs-type">int</span> round=<span class="hljs-number">1</span>; <span class="hljs-comment">//比较轮数</span><br>        <span class="hljs-keyword">while</span> (round&lt;=maxLen)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arrayList.size(); j++) &#123;<br>                <span class="hljs-type">int</span> len=arrayList.get(j).length();<br>                <span class="hljs-keyword">if</span> (len&gt;=round)&#123;<br>                    bucketArr.get(arrayList.get(j).charAt(len-round)).add(arrayList.get(j));<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    bucketArr.get(arrayList.get(j).charAt(<span class="hljs-number">0</span>)).add(arrayList.get(j));<br>                &#125;<br>            &#125;<br><br>            arrayList.clear(); <span class="hljs-comment">//清除旧数据，重新放入元素</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketArr.size(); i++) &#123;<br>                <span class="hljs-keyword">if</span> (bucketArr.get(i).size()&gt;<span class="hljs-number">0</span>)&#123;<br>                    Iterator&lt;String&gt; iterator=bucketArr.get(i).iterator();<br>                    <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>                        arrayList.add(iterator.next());<br>                    &#125;<br>                    bucketArr.get(i).clear(); <span class="hljs-comment">//清除每个桶的数据</span><br>                &#125;<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;当前是第【&quot;</span>+round+<span class="hljs-string">&quot;]轮，结果为：&quot;</span>);<br>            PrintArray.print(arrayList);<br>            round++; <span class="hljs-comment">//进入下一轮</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> arrayList;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; SRC=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        SRC.add(<span class="hljs-string">&quot;bcde&quot;</span>);<br>        SRC.add(<span class="hljs-string">&quot;fhgs&quot;</span>);<br>        SRC.add(<span class="hljs-string">&quot;e&quot;</span>);<br>        SRC.add(<span class="hljs-string">&quot;dasdegj&quot;</span>);<br>        SRC.add(<span class="hljs-string">&quot;abd&quot;</span>);<br>        SRC.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        SRC.add(<span class="hljs-string">&quot;epvrs&quot;</span>);<br>        SRC.add(<span class="hljs-string">&quot;gpoweewr&quot;</span>);<br>        PrintArray.print(SRC);<br>        System.out.println(<span class="hljs-string">&quot;======================================&quot;</span>);<br>        ArrayList&lt;String&gt; res= RadixSortString.sort(SRC);<br>        PrintArray.print(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>基数排序有两种方法：</p><ul><li>MSD 从高位开始进行排序</li><li>LSD 从低位开始进行排序</li></ul><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><h3 id="11-外部排序"><a href="#11-外部排序" class="headerlink" title="11.外部排序"></a>11.外部排序</h3><img src="/2022/06/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F.png" class="" title="外部排序"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>排序算法</th><th><strong>平均时间复杂度</strong></th><th><strong>最好情况</strong></th><th><strong>最坏情况</strong></th><th><strong>空间复杂度</strong></th><th><strong>稳定性</strong></th><th><strong>比较算法</strong></th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td><td>是</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td><td>是</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td><td>是</td></tr><tr><td>希尔排序</td><td>不确定</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td><td>是</td></tr><tr><td>归并排序</td><td>O(nlog n)</td><td>O(nlog n)</td><td>O(nlog n)</td><td>O(n)</td><td>稳定</td><td>是</td></tr><tr><td>快速排序</td><td>O(nlog n)</td><td>O(nlog n)</td><td>O(n^2)</td><td>O(log n)</td><td>不稳定</td><td>是</td></tr><tr><td>堆排序</td><td>O(nlog n)</td><td>O(nlog n)</td><td>O(nlog n)</td><td>O(1)</td><td>不稳定</td><td>是</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>稳定</td><td>否</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n^2)</td><td>O(n+k)</td><td>稳定</td><td>否</td></tr><tr><td>基数排序</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n+k)</td><td>稳定</td><td>否</td></tr></tbody></table><p><strong>算法稳定性</strong></p><ul><li><p>稳定：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面；</p></li><li><p>不稳定：如果a原本在b的前面，而a&#x3D;b，排序之后a可能会出现在b的后面；</p></li><li><p>排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。</p></li></ul><p><strong>算法复杂度</strong></p><ul><li>算法的复杂度往往取决于数据的规模大小和数据本身分布性质。</li><li>时间复杂度： 一个算法执行所耗费的时间。</li><li>空间复杂度：对一个算法在运行过程中临时占用存储空间大小的量度。</li><li>常见复杂度由小到大：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n)</li></ul><p>在各种不同算法中，若算法中语句执行次数(占用空间)为一个常数，则复杂度为O(1)；当一个算法的复杂度与以2为底的n的对数成正比时，可表示为O(log n)；当一个算法的复杂度与n成线性比例关系时，可表示为O (n)，依次类推。</p><p><strong>时间复杂度记忆</strong> </p><ul><li>冒泡、选择、插入排序需要两个for循环，每次只关注一个元素，平均时间复杂度为**O(n^2)**（一遍找元素O(n)，一遍找位置O(n)）</li><li>快速、归并、堆基于分治思想，log以2为底，平均时间复杂度往往和O(nlogn)（一遍找元素O(n)，一遍找位置O(logn)）相关</li><li>而希尔排序依赖于所取增量序列的性质，但是到目前为止还没有一个最好的增量序列 。例如希尔增量序列时间复杂度为O(n²)，有人在大量的实验后得出结论：<strong>当n在某个特定的范围后希尔排序的最小时间复杂度大约为n^1.3</strong>。</li></ul><p><strong>从平均时间来看，快速排序是效率最高的</strong>：快速排序中平均时间复杂度O(nlog n)，这个公式中隐含的常数因子很小，比归并排序的O(nlog n)中的要小很多，所以大多数情况下，快速排序总是优于合并排序的。</p><p>而堆排序的平均时间复杂度也是O(nlog n)，但是堆排序存在着重建堆的过程，它把根节点移除后，把最后的叶子结点拿上来后需要重建堆，但是，拿上的值是要比它的两个叶子结点要差很多的，一般要比较很多次，才能回到合适的位置。堆排序就会有很多的时间耗在堆调整上。</p><p>虽然快速排序的最坏情况为排序规模（n）的平方关系，但是这种最坏情况取决于每次选择的基准， 对于这种情况，已经提出了很多优化的方法，比如三取样划分和Dual-Pivot快排。同时，当排序规模较小时，划分的平衡性容易被打破，而且频繁的方法调用超过了O(nlog n)为O(n^2)省出的时间，所以一般排序规模较小时，会改用插入排序或者其他排序算法。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/24/hello-world/"/>
    <url>/2022/06/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
