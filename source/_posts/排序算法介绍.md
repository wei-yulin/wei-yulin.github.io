---
title: 排序算法介绍
tags: 算法
categories: 排序算法
date: 2022-06-25 16:31:16
---

### 排序算法概述

排序是将一组对象按照某种逻辑顺序重新排列过程。比如，订单按照日期排序，这种排序很可能使用了某种排序算法。现在计算机的使用很广泛，随之差生的数据无处不在，而整理数据的第一步通常就是排序。	

十大排序算法：冒泡排序、选择排序、插入排序、归并排序、堆排序、快速排序、希尔排序、计数排序、基数排序、桶排序

### 1.冒泡排序

一种简单的排序算法。它反复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。这个工作重复地进行直到没有元素再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为元素会经由交换慢慢“浮”到数列的顶端。 

**操作步骤**

1. 从数组头开始，比较相邻的元素。如果第一个比第二个大(小)，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到尾部的最后一对，这样在最后的元素应该会是最大(小)的数；
3. 重复步骤1~2，重复次数等于数组的长度，直到排序完成。

**图示**

{% asset_img 冒泡排序.png 冒泡排序 %}

**代码实现**

```java
    public static int[] sort(int[] array) {

        if (array.length<1){
            return array;
        }

        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length - 1 - i; j++) {
                if (array[j]>array[j+1]){
                    int temp=array[j+1];
                    array[j+1]=array[j];
                    array[j]=temp;
                }
            }
        }

        return array;
    }
```

### 2.选择排序

**操作步骤**

1. 首先，找到数组中最大（小）的那个元素
2. 其次，将它和数组的第一个元素交换位置（如果第一个元素就是最大（小）元素那么它就和自己交换）
3. 再次，在剩下的元素中找到最大（小）的元素，将它与数组的第二个元素交换位置
4. 如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最大（小）者

**图示**

{% asset_img 选择排序.png 选择排序 %}

**代码实现**

```java
    public static int[] sort(int[] array){

        if (array.length<1){
            return array;
        }
        for (int i = 0; i < array.length; i++) {
            int min=i;
            for (int j = i; j < array.length; j++) {
                if (array[j]<array[min]) {
                    min=j;
                }
            }
            int temp=array[i];
            array[i]=array[min];
            array[min]=temp;
        }
        return array;
    }
```

### 3.插入排序

对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。为了给要插入的元素腾出空间，我们需要将插入位置之后的已排序元素在都向后移动一位。插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快得多。总的来说，插入排序对于部分有序的数组十分高效，也很适合小规模数组

**图示**

{% asset_img 插入排序.png 插入排序 %}

**代码实现**

```java
    public static int[] sort(int[] array) {
        if (array.length<1){
            return array;
        }

        for (int i = 0; i < array.length; i++) {
            int currentValue=array[i];
            int preIndex=i-1;
            while (preIndex >= 0 && array[preIndex] > currentValue) {
                array[preIndex+1]=array[preIndex];
                preIndex--;
            }
            array[preIndex+1]=currentValue;
        }
        return array;
    }
```

### 4.希尔排序

一种基于**插入排序**的快速的排序算法。简单插入排序对于大规模乱序数组很慢，因为元素只能一点一点地从数组的一端移动到另一端。例如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需要N-1 次移动。

希尔排序为了加快速度简单地改进了插入排序，也称为缩小增量排序，同时该算法是突破O(n^2）的第一批算法之一。

希尔排序是把待排序数组按一定数量的分组，对每组使用直接插入排序算法排序；然后缩小数量继续分组排序，随着数量逐渐减少，每组包含的元素越来越多，当数量减至 1 时，整个数组恰被分成一组，排序便完成了。这个不断缩小的数量，就构成了一个增量序列。

**图示**

{% asset_img 希尔排序.png 希尔排序 %}

**代码实现**

```java
    public static int[] sort(int[] array){

        int len=array.length;
        // 确定分组步长，逐渐减小直至未1，此时整个数组排序完成
        int gap=len/2;

        while (gap>0){
            for (int i=gap;i<len;i++){ //当前元素与组内已有元素对比
                int currentValue=array[i];
                int preIndex=i-gap; //组内的前一个元素索引
                while (preIndex>=0 && array[preIndex]>currentValue){
                    array[preIndex+gap]=array[preIndex];
                    preIndex=preIndex-gap;
                }
                array[preIndex+gap]=currentValue;
            }
            gap=gap/2;
        }

        return array;
    }
```

### 5.归并排序

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。对于给定的一组数据，利用递归与分治技术将数据序列划分成为越来越小的半子表，在对半子表排序后，再用递归方法将排好序的半子表合并成为越来越大的有序序列。为了提升性能，有时我们在半子表的个数小于某个数（比如15）的情况下，对半子表的排序采用其他排序算法，比如插入排序。若将两个有序表合并成一个有序表，称为2-路归并，与之对应的还有多路归并。

**图示**

{% asset_img 归并排序.png 归并排序 %}

**代码实现**

```java
    public static int[] sort(int[] array) {
        if (array.length < 2) { //只有一个元素的时候说明已是最小粒度，开始合并
            return array;
        }
        int mid = array.length / 2;
        int[] left = Arrays.copyOfRange(array, 0, mid);
        int[] right = Arrays.copyOfRange(array, mid, array.length);
        return merge(sort(left), sort(right));
    }

    private static int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int index, leftIndex, rightIndex;
        for (index = 0, leftIndex = 0, rightIndex = 0; index < result.length; index++) {
            if (leftIndex >= left.length) { //如果左边已经全排完，右队列依次填入结果
                result[index] = right[rightIndex++];
            } else if (rightIndex >= right.length) {//如果右边已经全排完，左队列依次填入结果
                result[index] = left[leftIndex++];
            } else if (left[leftIndex] > right[rightIndex]) {
                result[index] = right[rightIndex++];
            } else {
                result[index] = left[leftIndex++];
            }
        }

        return result;
    }
```

### 6.快速排序

快速排序（Quicksort）是对冒泡排序的一种改进，也是采用分治法的一个典型的应用。首先任意选取一个数据（比如数组的第一个数）作为关键数据，我们称为基准数(Pivot)，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序，也称为分区（partition）操作。通过一趟快速排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数组变成有序序列。为了提升性能，有时我们在分割后独立的两部分的个数小于某个数（比如15）的情况下，会采用其他排序算法，比如插入排序。

**基准的选取**：最优的情况是基准值刚好取在无序区数值的中位数，这样能够最大效率地让两边排序，同时最大地减少递归划分的次数，但是一般很难做到最优。基准的选取一般有三种方式，选取数组的第一个元素，选取数组的最后一个元素，以及选取第一个、最后一个以及中间的元素的中位数（如4 5 6 7, 第一个4, 最后一个7, 中间的为5, 这三个数的中位数为５, 所以选择5作为基准）。Dual-Pivot快排：双基准快速排序算法，其实就是用两个基准数, 把整个数组分成三份来进行快速排序，在这种新的算法下面，比经典快排从实验来看节省了10%的时间。

**图示**

{% asset_img 快速排序.png 快速排序 %}

**代码实现**

```java
    public static int[] sort(int[] array, int start, int end) {
        if (start < 0 || end < 0 || start > end || array.length < 1 || end >= array.length || start>=array.length) { //数组为1结束
            return null;
        }
        int pivot = array[end]; //取最后一个元素为基数
        int zoneIndex = start - 1; //分区指针
        for (int i = start; i <= end; i++) {
            if (array[i] <= pivot) {
                zoneIndex++;
                if (i > zoneIndex) {
                    swap(array, i, zoneIndex);
                }
            }
        }
       
        if (zoneIndex > start) {
            sort(array, start, zoneIndex - 1);
        }
        if (zoneIndex < end) {
            sort(array, zoneIndex + 1, end);
        }
        return array;
    }

    public static void swap(int[] array, int from, int to) {
        int temp = array[to];
        array[to] = array[from];
        array[from] = temp;
    }
```

### 7.堆排序

许多应用程序都需要处理有序的元素，但不一定要求他们全部有序，或者不一定要一次就将他们排序，很多时候，我们每次只需要操作数据中的最大元素（最小元素），那么有一种基于二叉堆的数据结构可以提供支持。所谓二叉堆，是一个完全二叉树的结构，同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。在一个二叉堆中，根节点总是最大（或者最小）节点。堆排序算法就是抓住了这一特点，每次都取堆顶的元素，然后将剩余的元素重新调整为最大（最小）堆，依次类推，最终得到排序的序列。

**图示**

{% asset_img 二叉树.png 二叉树 %}

{% asset_img 堆排序.png 堆排序 %}

**代码实现**

```java

    public static int len;

    public static int[] sort(int[] array) {
        len = array.length;
        if (len <= 1) {
            return array;
        }
        buildMaxHeap(array);

        while (len > 1) {
            swap(array, 0, len - 1);
            len--;
            adjustHeap(array, 0);
        }
        return array;
    }

    public static void buildMaxHeap(int[] array) {
        for (int i = (len / 2 - 1); i >= 0; i--) {
            adjustHeap(array, i);
        }
    }

    public static void adjustHeap(int[] array, int i) {
        int maxIndex = i;
        int left = 2 * i + 1;
        int right = 2 * (i + 1);
        if (left < len && array[left] > array[maxIndex]) {
            maxIndex = left;
        }
        if (right < len && array[right] > array[maxIndex]) {
            maxIndex = right;
        }
        if (maxIndex != i) {
            swap(array, maxIndex, i);
            adjustHeap(array, maxIndex);
        }
    }

    public static void swap(int[] array, int from, int to) {
        int temp = array[to];
        array[to] = array[from];
        array[from] = temp;
    }
```

### 8.计数排序

计数排序对一定范围内的整数排序时候的速度非常快，一般快于其他排序算法。但计数排序局限性比较大，只限于对整数进行排序，而且待排序元素值分布较连续、跨度小的情况。计数排序是一个排序时不比较元素大小的排序算法。如果一个数组里所有元素都是整数，而且都在0-K以内。对于数组里每个元素来说，如果能知道数组里有多少项小于或等于该元素，就能准确地给出该元素在排序后的数组的位置。

实际应用中我们会同时找出数组中的max和min，主要是为了尽量节省空间。试想[1003, 1001, 1030, 1050]这样的数据要排序，真的需要建立长度为1050 + 1的数组吗？我们只需要长度为1050 - 1003 + 1= 48的数组（先不考虑额外+1的长度），就能囊括从最小到最大元素之间的所有元素了。如果待排序数组的元素值跨度很大，比如[99999, 1, 2]，为三个元素排序要使用99999 - 1 + 1的空间，实在是浪费。**所以计数排序适用于待排序元素值分布较连续、跨度小的情况。**

**图示**

{% asset_img 计数排序.png 计数排序 %}

**代码实现**

```java
    public static int[] sort(int[] array){
        int len=array.length;
        if (len<2){
            return array;
        }

        int min=array[0];
        int max=array[0];
        for (int i = 0; i < array.length; i++) {
            if (array[i]>max){
                max=array[i];
            }
            if (array[i]<min){
                min=array[i];
            }
        }
        int bias=0-min; //偏移量，为了把原始数组中最小值映射到计数数组的0起始位置
        int[] countArray=new int[max-min+1];
        Arrays.fill(countArray,0);
        //遍历数组，将原始数组元素映射到计数数组的下标位置，并计数
        for (int i = 0; i < array.length; i++) {
            countArray[bias+array[i]]++;
        }
        System.out.println("计数数组为：");
        PrintArray.print(countArray);

        int pos=0; //原始数组的起始位置
        for (int i = 0; i < countArray.length; i++) {
            while (countArray[i]>0){
                countArray[i]--;
                array[pos]=i-bias;
                pos++;
            }
        }
        return array;
    }
```

### 9.桶排序

桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，利用某种函数的映射关系将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序）。 

桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做排序即可。

**图示**

{% asset_img 桶排序.png 桶排序 %}

**代码实现**

```java
public class BucketSort {

    /**
     * @param array      待排序数组
     * @param bucketSize 桶容量
     * @return
     */
    public static ArrayList<Integer> sort(ArrayList<Integer> array, int bucketSize) {
        System.out.println("arraySize:"+array.size()+", bucketSize:"+bucketSize);
        if (array == null || array.size() < 2) {
            return array;
        }

        int len=array.size();

        int min = array.get(0);
        int max = array.get(0);
        for (int i = 0; i < len; i++) {
            if (array.get(i) > max) {
                max = array.get(i);
            }
            if (array.get(i) < min) {
                min = array.get(i);
            }
        }
        /*初始化桶容器*/
        int bucketCount = (max - min) / bucketSize + 1;
        ArrayList<ArrayList<Integer>> bucketArr = new ArrayList<>(bucketCount); //初始化桶个数
        for (int i = 0; i < bucketCount; i++) {
            bucketArr.add(new ArrayList<Integer>());
        }

        /*数据放入每个桶中*/
        for (int i = 0; i < len; i++) {
            bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));
        }

        /*查看桶中数据存放情况*/
        for (int i = 0; i < bucketArr.size(); i++) {
            System.out.println("第【"+i+"】个桶中的元素是：");
            ArrayList<Integer> list=bucketArr.get(i);
            Iterator<Integer> iterator=list.iterator();
            while (iterator.hasNext()){
                System.out.print(iterator.next()+" ");
            }
            System.out.println("");
        }

        ArrayList<Integer> resultArr=new ArrayList<>();
        for (int i = 0; i < bucketArr.size(); i++) {
            ArrayList<Integer> list=bucketArr.get(i);
            if (list.size()>1){
                System.out.println("第【"+i+"]个桶元素需要重新排序");
                list=sort(list,bucketSize/2);
            }
            Iterator<Integer> iterator=list.iterator();
            while (iterator.hasNext()){
                resultArr.add(iterator.next());
            }
        }
        return resultArr;
    }

    public static void main(String[] args) {
//        Integer[] array={4,6,8,9,2,17,25};
        ArrayList<Integer> SRC=new ArrayList<>();
        SRC.add(4);
        SRC.add(9);
        SRC.add(17);
        SRC.add(8);
        SRC.add(6);
        SRC.add(25);
        SRC.add(2);
        PrintArray.print(SRC);
        System.out.println("======================================");
        ArrayList<Integer> res= BucketSort.sort(SRC,4);
        PrintArray.print(res);
    }
}
```

### 10.基数排序

常见的数据元素一般是由若干位组成的，比如字符串由若干字符组成，整数由若干位0~9数字组成。基数排序按照从右往左的顺序，依次将每一位都当做一次关键字，然后按照该关键字对数组排序，同时每一轮排序都基于上轮排序后的结果；当我们将所有的位排序后，整个数组就达到有序状态。基数排序不是基于比较的算法。基数是什么意思？对于十进制整数，每一位都只可能是0~9中的某一个，总共10种可能。那10就是它的基，同理二进制数字的基为2；对于字符串，如果它使用的是8位的扩展ASCII字符集，那么它的基就是256。 

**图示**

{% asset_img 基数排序.png 基数排序 %}

**代码实现**

```java
public class RadixSortInt {

    public static int[] sort(int[] array) {
        if (array == null || array.length < 2) {
            return array;
        }
        /*找出最大数*/
        int max = array[0];
        for (int i = 1; i < array.length; i++) {
            max = Math.max(max, array[i]);
        }

        /*先算出最大数的位数*/
        int maxDigit = 0;
        while (max != 0) {
            max /= 10;
            maxDigit++;
        }
        int mod = 10, div = 1;
        /*构建桶*/
        ArrayList<ArrayList<Integer>> bucketList = new ArrayList<ArrayList<Integer>>();
        for (int i = 0; i < 10; i++) {
            bucketList.add(new ArrayList<Integer>());
        }
        /*按照从右往左的顺序，依次将每一位都当做一次关键字，然后按照该关键字对数组排序，
        每一轮排序都基于上轮排序后的结果*/
        for (int i = 0; i < maxDigit; i++, mod *= 10, div *= 10) {
            /*遍历原始数组，投入桶中*/
            for (int j = 0; j < array.length; j++) {
                int num = (array[j] % mod) / div;
                bucketList.get(num).add(array[j]);
            }
            /*桶中的数据写回原始数组，清除桶，准备下一轮的排序*/
            int index = 0;
            for (int j = 0; j < bucketList.size(); j++) {
                for (int k = 0; k < bucketList.get(j).size(); k++) {
                    array[index++] = bucketList.get(j).get(k);
                }
                bucketList.get(j).clear();
            }
        }
        return array;
    }

    public static void main(String[] args) {

        int[] SRC = {86, 11, 77, 22, 32, 45, 58, 63, 93, 4, 37, 23};
        PrintArray.print(SRC);
        System.out.println("============================================");
        int[] dest = RadixSortInt.sort(PrintArray.SRC);
        PrintArray.print(dest);
    }
}
```

**基数排序 vs 计数排序 vs 桶排序**

基数排序有两种方法：

* MSD 从高位开始进行排序
* LSD 从低位开始进行排序 

这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：

* 基数排序：根据键值的每位数字来分配桶
* 计数排序：每个桶只存储单一键值
* 桶排序：每个桶存储一定范围的数值

### 11.外部排序

{% asset_img 外部排序.png 外部排序 %}

### 总结

| 排序算法 | **平均时间复杂度** | **最好情况** | **最坏情况** | **空间复杂度** | **稳定性** | **比较算法** |
| -------- | ------------------ | ------------ | ------------ | -------------- | ---------- | ------------ |
| 冒泡排序 | O(n^2)             | O(n)         | O(n^2)       | O(1)           | 稳定       | 是           |
| 选择排序 | O(n^2)             | O(n^2)       | O(n^2)       | O(1)           | 不稳定     | 是           |
| 插入排序 | O(n^2)             | O(n)         | O(n^2)       | O(1)           | 稳定       | 是           |
| 希尔排序 | 不确定             | O(n^2)       | O(n^2)       | O(1)           | 不稳定     | 是           |
| 归并排序 | O(nlog n)          | O(nlog n)    | O(nlog n)    | O(n)           | 稳定       | 是           |
| 快速排序 | O(nlog n)          | O(nlog n)    | O(n^2)       | O(log n)       | 不稳定     | 是           |
| 堆排序   | O(nlog n)          | O(nlog n)    | O(nlog n)    | O(1)           | 不稳定     | 是           |
| 计数排序 | O(n+k)             | O(n+k)       | O(n+k)       | O(k)           | 稳定       | 否           |
| 桶排序   | O(n+k)             | O(n+k)       | O(n^2)       | O(n+k)         | 稳定       | 否           |
| 基数排序 | O(n*k)             | O(n*k)       | O(n*k)       | O(n+k)         | 稳定       | 否           |

**算法稳定性**

* 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；

* 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；

* 排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。

**算法复杂度**

* 算法的复杂度往往取决于数据的规模大小和数据本身分布性质。
* 时间复杂度： 一个算法执行所耗费的时间。
* 空间复杂度：对一个算法在运行过程中临时占用存储空间大小的量度。
* 常见复杂度由小到大：O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n)

在各种不同算法中，若算法中语句执行次数(占用空间)为一个常数，则复杂度为O(1)；当一个算法的复杂度与以2为底的n的对数成正比时，可表示为O(log n)；当一个算法的复杂度与n成线性比例关系时，可表示为O (n)，依次类推。

**时间复杂度记忆** 

* 冒泡、选择、插入排序需要两个for循环，每次只关注一个元素，平均时间复杂度为**O(n^2)**（一遍找元素O(n)，一遍找位置O(n)）
* 快速、归并、堆基于分治思想，log以2为底，平均时间复杂度往往和O(nlogn)（一遍找元素O(n)，一遍找位置O(logn)）相关
* 而希尔排序依赖于所取增量序列的性质，但是到目前为止还没有一个最好的增量序列 。例如希尔增量序列时间复杂度为O(n²)，有人在大量的实验后得出结论：**当n在某个特定的范围后希尔排序的最小时间复杂度大约为n^1.3**。

**从平均时间来看，快速排序是效率最高的**：快速排序中平均时间复杂度O(nlog n)，这个公式中隐含的常数因子很小，比归并排序的O(nlog n)中的要小很多，所以大多数情况下，快速排序总是优于合并排序的。

而堆排序的平均时间复杂度也是O(nlog n)，但是堆排序存在着重建堆的过程，它把根节点移除后，把最后的叶子结点拿上来后需要重建堆，但是，拿上的值是要比它的两个叶子结点要差很多的，一般要比较很多次，才能回到合适的位置。堆排序就会有很多的时间耗在堆调整上。

虽然快速排序的最坏情况为排序规模（n）的平方关系，但是这种最坏情况取决于每次选择的基准， 对于这种情况，已经提出了很多优化的方法，比如三取样划分和Dual-Pivot快排。同时，当排序规模较小时，划分的平衡性容易被打破，而且频繁的方法调用超过了O(nlog n)为O(n^2)省出的时间，所以一般排序规模较小时，会改用插入排序或者其他排序算法。
