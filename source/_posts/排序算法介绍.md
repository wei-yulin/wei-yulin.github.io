---
title: 排序算法介绍
tags: 算法
categories: 算法
date: 2022-06-25 16:31:16
---

### 排序算法概述

排序是将一组对象按照某种逻辑顺序重新排列过程。比如，订单按照日期排序，这种排序很可能使用了某种排序算法。现在计算机的使用很广泛，随之差生的数据无处不在，而整理数据的第一步通常就是排序。	

十大排序算法：冒泡排序、选择排序、插入排序、归并排序、堆排序、快速排序、希尔排序、计数排序、基数排序、桶排序

### 1.冒泡排序

一种简单的排序算法。它反复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。这个工作重复地进行直到没有元素再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为元素会经由交换慢慢“浮”到数列的顶端。 

**操作步骤**

1. 从数组头开始，比较相邻的元素。如果第一个比第二个大(小)，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到尾部的最后一对，这样在最后的元素应该会是最大(小)的数；
3. 重复步骤1~2，重复次数等于数组的长度，直到排序完成。

**图示**

{% asset_img 冒泡排序图示1.png 冒泡排序 %}

**代码实现**

```java
    public static int[] sort(int[] array) {

        if (array.length<1){
            return array;
        }

        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length - 1 - i; j++) {
                if (array[j]>array[j+1]){
                    int temp=array[j+1];
                    array[j+1]=array[j];
                    array[j]=temp;
                }
            }
        }

        return array;
    }
```

### 2.选择排序

**操作步骤**

1. 首先，找到数组中最大（小）的那个元素
2. 其次，将它和数组的第一个元素交换位置（如果第一个元素就是最大（小）元素那么它就和自己交换）
3. 再次，在剩下的元素中找到最大（小）的元素，将它与数组的第二个元素交换位置
4. 如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最大（小）者

**图示**

{% asset_img 选择排序.png 选择排序 %}

**代码实现**

```java
    public static int[] sort(int[] array){

        if (array.length<1){
            return array;
        }
        for (int i = 0; i < array.length; i++) {
            int min=i;
            for (int j = i; j < array.length; j++) {
                if (array[j]<array[min]) {
                    min=j;
                }
            }
            int temp=array[i];
            array[i]=array[min];
            array[min]=temp;
        }
        return array;
    }
```

### 3.插入排序

对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。为了给要插入的元素腾出空间，我们需要将插入位置之后的已排序元素在都向后移动一位。插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快得多。总的来说，插入排序对于部分有序的数组十分高效，也很适合小规模数组

**图示**

{% asset_img 插入排序1.png 插入排序1 %}

{% asset_img 插入排序2.png 插入排序2 %}

**代码实现**

```java
    public static int[] sort(int[] array) {
        if (array.length<1){
            return array;
        }

        for (int i = 0; i < array.length; i++) {
            int currentValue=array[i];
            int preIndex=i-1;
            while (preIndex >= 0 && array[preIndex] > currentValue) {
                array[preIndex+1]=array[preIndex];
                preIndex--;
            }
            array[preIndex+1]=currentValue;
        }
        return array;
    }
```

### 4.希尔排序

一种基于**插入排序**的快速的排序算法。简单插入排序对于大规模乱序数组很慢，因为元素只能一点一点地从数组的一端移动到另一端。例如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需要N-1 次移动。

希尔排序为了加快速度简单地改进了插入排序，也称为缩小增量排序，同时该算法是突破O(n^2）的第一批算法之一。

希尔排序是把待排序数组按一定数量的分组，对每组使用直接插入排序算法排序；然后缩小数量继续分组排序，随着数量逐渐减少，每组包含的元素越来越多，当数量减至 1 时，整个数组恰被分成一组，排序便完成了。这个不断缩小的数量，就构成了一个增量序列。

{% asset_img 希尔排序1.png 希尔排序1 %}

{% asset_img 希尔排序2.png 希尔排序2 %}

**代码实现**

```java
    public static int[] sort(int[] array){

        int len=array.length;
        // 确定分组步长，逐渐减小直至未1，此时整个数组排序完成
        int gap=len/2;

        while (gap>0){
            for (int i=gap;i<len;i++){ //当前元素与组内已有元素对比
                int currentValue=array[i];
                int preIndex=i-gap; //组内的前一个元素索引
                while (preIndex>=0 && array[preIndex]>currentValue){
                    array[preIndex+gap]=array[preIndex];
                    preIndex=preIndex-gap;
                }
                array[preIndex+gap]=currentValue;
            }
            gap=gap/2;
        }

        return array;
    }
```
